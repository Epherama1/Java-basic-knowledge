一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核
Linux 的系统调用主要有以下这些：
进程控制	fork(); exit(); wait();
进程通信	pipe(); shmget(); mmap();
文件操作	open(); read(); write();
设备操作	ioctl(); read(); write();
信息维护	getpid(); alarm(); sleep();
安全	chmod(); umask(); chown();


进程管理：
通信方面进程和线程的区别：
线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

进程间通信方式：https://blog.csdn.net/J080624/article/details/87454764
根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:
低级通信：控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)
高级通信：大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等)。

1.管道通信：
一个进程在管道的尾部写入数据，另一个进程从管道的头部读出数据。管道包括无名管道和有名管道两种，前者只能用于父进程和子进程间的通信，后者可用于运行于同一系统中的任意两个进程间的通信。

管道通信特点： 
1. 管道通讯是单向的，有固定的读端和写端。 
2. 数据被进程从管道读出后，在管道中该数据就不存在了。 
3. 当进程去读取空管道的时候，进程会阻塞。 
4. 当进程往满管道写入数据时，进程会阻塞。 
5. 管道容量为64KB（#define PIPE_BUFFERS 16 include/linux/pipe_fs_i.h）

无名管道（pipe）：
是 UNIX 系统IPC最古老的形式，是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。
在Linux系统中，无名管道一旦创建完成后，操作无名管道等同于操作文件。无名管道的读端被视作一个文件；无名管道的写端也被视作一个文件。因此可以使用read，write，close等文件操作函数来访问无名管道。
有名管道（FIFO）：
有名管道又称为FIFO文件（先进先出），因此我们对有名管道的操作也可以采用操作文件的方法，如使用open，read，write等。可用于运行于同一系统中的任意两个进程间的通信。
FIFO文件对比普通文件： 
FIFO文件在使用上和普通文件有相似之处，但是也有 不同之处： 
1. 读取Fifo文件的进程只能以”RDONLY”方式打开fifo文件。 
2. 写Fifo文件的进程只能以”WRONLY”方式打开fifo文件。 
3. Fifo文件里面的内容被读取后，就消失了。但是普通文件里面的内容读取后还存在。

2.消息队列：
消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。
消息队列场景：异步、削峰、解耦
异步：
流程里面多100ms去扣减优惠券，流程里面多了200ms去增减积分，100ms去发个短信。
再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms
那为什么不用线程池来实现异步：耦合：
A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？
全部都写在一起的话，耦合，出问题排查麻烦，流程里面随便一个地方出问题会影响到其他的点
你下单了，你就把你支付成功的消息告诉别的系统，他们收到了去处理就好了
削峰：
秒杀：把请求放到队列里面，然后至于每秒消费多少请求，就看自己的服务器处理能力。可能会比正常的慢一点，但是不至于打挂服务器，等流量高峰下去了，你的服务也就没压力了。
消息队列缺点：
系统复杂性：
凭空接入一个中间件在那，要去维护他，各种问题：消息重复消费、消息丢失、消息的顺序消费等等     ？？？这些问题是啥？
数据一致性：
分布式事务：把下单，优惠券，积分...都放在一个事务里面一样，要成功一起成功，要失败一起失败。Kafka，RabbitMQ

3.共享内存：
共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。
共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

4.信号(Signal)和信号量(semaphore)

5.套接字(Socket)：
更为一般的进程间通信机制，可用于不同机器之间的进程间通信。

linux下的进程包含以下几个关键要素：
有一段可执行程序；
有专用的系统堆栈空间；
内核中有它的控制块（进程控制块），描述进程所占用的资源，这样，进程才能接受内核的调度；
具有独立的存储空间

线程间同步：
线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。
1. 锁机制：互斥锁、条件变量、读写锁和自旋锁。
2. 信号机制(Signal)和信号量机制(Semaphore)。
3. violate全局变量-共享内存
4. wait/notify：如何才能在当前线程还没退出synchronized数据块时让其他线程也有机会访问共享数据呢？
5. join()
6. CountDownLatch
7. CyclicBarrier
8. 线程池

保证线程安全手段：
同步机制：监视器锁(synchronized)、显示锁(ReentrantLock、RReadWriteLock)、原子变量(AtomicInteger/AtomciLong)、Volatile；
栈封闭：ThreadLocal
对象创建后不可更改。

ThreadLocal：
每个使用该变量的线程都会初始化一个完全独立的实例副本。
因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来
既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题
每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal->value 键值对插入到该 Map 中。


yield方法与sleep方法区别说明如下：
sleep 方法使当前运行中的线程睡眠一段时间，进入不可以运行状态(停滞状态-waiting)，这段时间的长短是由程序设定的 ;
sleep方法和join方法都可以使低优先级线程获得执行机会，但是yield方法不能使低优先级线程获得执行机会；
yield方法使当前线程让出CPU占有权，但让出的时间是不可设定的 ;
yield方法与sleep不同的是，会使线程处于就绪状态，可能下一秒就被执行；
yield和sleep都不会释放对象锁标志，wait会释放锁。

sleep与wait区别：
sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

以下情况将会释放锁：
当前线程的同步方法、同步代码块执行结束。
当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。
当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。
当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁(sleep不会释放锁)。
以下情况不会释放锁：
线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行。
线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。

死锁：
不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。

进程切换：
1.为什么分内核态和用户态：
假设没有这种内核态和用户态之分，程序随随便便就能访问硬件资源，比如说分配内存，程序能随意的读写所有的内存空间，如果程序员一不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。
用户程序进行系统调用后，操作系统执行一系列的检查验证，确保这次调用是安全的，再进行相应的资源访问操作。内核态能有效保护硬件资源的安全。





进程调度算法：
1. 批处理系统
批处理系统没有太多的用户操作，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。      吞吐量和周转时间？？？
1.1 先来先服务 first-come first-serverd（FCFS）：按照请求的顺序进行调度。
非抢占式的调度算法，有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

1.2 短作业优先 shortest job first（SJF）
非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

1.3 最短剩余时间优先 shortest remaining time next（SRTN）
最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

2. 交互式系统
交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

2.1 时间片轮转

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
而如果时间片过长，那么实时性就不能得到保证。


2.2 优先级调度

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

2.3 多级反馈队列

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。










32位与64位的区别：
1、处理数据的能力
32位和64位表示CPU一次能处理的最大位数，64位系统处理的数据效率比32位更高，相当于 单车道和双车道开车似得，双车道单位时间可以有更多的车辆通行。但需要内存跟上，而且程序本身也是64位编译才能发挥64位系统的优势。
2、支持的内存不同（寻址能力不同）
寻址能力是指，电脑能在多大的空间里（内存）找到一个软件的数据被存放在哪里。
32位系统的最大寻址空间是2的32次方，4（GB）左右；而64位系统的最大寻址空间为2的64次方，数值大于1亿GB。不过那也只是理论值而已，实际使用过程中大多数的电脑32位系统最多识别3.5GB内存，64位系统最多识别128GB内存。
3、软件兼容性
32位系统无法运行64位软件，64位系统可以安装多数32位软件，以前因为大部分软件都是基于32位架构环境下开发，所以64位系统的兼容性不如32位。






脏读（读取未提交数据）
A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。

不可重复读（前后多次读取，数据内容不一致）
事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间。和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。

幻读（前后多次读取，数据总量不一致）
事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样。

不可重复读和幻读到底有什么区别呢？
(1) 不可重复读是读取了其他事务更改的数据，针对update操作
解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。
(2) 幻读是读取了其他事务新增的数据，针对insert和delete操作
解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

数据库事务的四大特性：
原子性，要么执行，要么不执行
隔离性，所有操作全部执行完以前其它会话不能看到过程
一致性，事务前后，数据总额一致
持久性，一旦事务提交，对数据的改变就是永久的

1、原子性：事务包含的所有数据库操作要么全部成功，要不全部失败回滚
2、一致性：一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
3、隔离性：一个事务未提交的业务结果是否对于其它事务可见。级别一般有：read_uncommit，read_commit，read_repeatable，Serializable 串行化访问。
4、持久性：一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
只有满足一致性，事务的执行结果才是正确的。
在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
事务满足持久化是为了能应对系统崩溃的情况。

MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。
MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。
设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。
如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。


数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读
大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。
Mysql的默认隔离级别就是Repeatable read。

https://cloud.tencent.com/developer/article/1450773

读写锁：互斥锁X，共享锁S。对象A加了X锁，A就不能再加任何锁，可以读取和写入。加了S锁，只能读取，在这期间A只能被加S锁，不能加X锁。
意向锁：若想对表或表中的行进行操作，需要先对该表增加意向锁XI/SI。
1.若想对整个表加X锁，检查发现有XI/SI锁，则加X锁失败。
2.任意XI/SI锁都是兼容的，两个事务可以同时对表中的两行进行操作。

封锁协议？


隔离级别：
未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。
提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的。
可串行化（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

MVCC：
多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。
而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。
在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。
读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。
https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc

NEXT-KEY-locks：
MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

MYISAM	不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描
INNODB	支持外键，行锁，查表总行数时，全表扫描

非聚簇索引：
以myisam为例，一个数据表table中，它是有table.frm、table.myd以及table.myi组成。table.myd记录了数据，table.myi记录了索引的数据。
在用到索引时，先到table.myi（索引树）中进行查找，取到数据所在table.myd的行位置，拿到数据。所以myisam引擎的索引文件和数据文件是独立分开的，则称之为非聚簇索引。
myisam类型的索引，指向数据在行的位置。即每个索引相对独立，查询用到索引时，索引指向数据的位置。
聚簇索引
以innodb为例，在一个数据table中，它的数据文件和索引文件是同一个文件。即在查询过程中，找到了索引，便找到了数据文件。在innodb中，即存储主键索引值，又存储行数据，称之为聚簇索引。
？？？？
聚集索引	数据按索引顺序存储，中子结点存储真实的物理数据
非聚集索引	存储指向真正数据行的指针

红黑树	增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间
B树也就是B-树	B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。
B+树	B+树相比较于另外两种树,显得更矮更宽，查询层次更浅
B+树能显著减少IO次数，提高效率
B+树的查询效率更加稳定，因为数据放在叶子节点
B+树能提高范围查询的效率，因为叶子节点指向下一个叶子节点

varchar	字符长度经常变的
char	用字符长度固定的

数据库连接池的作用：
维护一定数量的连接，减少创建连接的时间
更快的响应时间
统一的管理

数据库中join的left join , inner join, cross join
1.以A，B两张表为例
A left join B
选出A的所有记录，B表中没有的以null 代替
right join 同理
2.inner join
A,B有交集的记录
3.cross join (笛卡尔积)
A中的每一条记录和B中的每一条记录生成一条记录
例如A中有4条，B中有4条，cross join 就有16条记录



实现中文：default charset = utf8

数据类型：
数字：tinyint, bigint, int, float, double(不精确小数), decimal(总位数，小数点后几位)(精确小数，可以指定精度，用字符串存)
字符串：最多255个字符，char(10)速度快，存数据的位置是固定的，长度不够用空格填充；varchar(10)，占空间小，位置不固定；text，longtext(4GB)
时间类型：DATATIME
enum枚举类型
set集合类型

清空表：delete from table / truncate table（快得多）
删除表：drop table
delete之后再插入数据，自增主键接着之前的序号，不是从1开始
修改自增的起始点：alter table t10 AUTO_INCREMENT = 20;

可以多个列一起作为主键->多个主键列同时作为外键，primary key(nid, pid)

索引：主键索引，普通索引，唯一索引，联合索引
索引需要创建额外的文件

主键和唯一索引的区别：
1.主键是一种约束，唯一索引是一种索引
2.一张表只能有一个主键但可以有多个唯一索引
3.主键不能为null，唯一索引可以为null
4.主键可以作为外键，唯一索引不行

一对一，权限表：两张表+外键+唯一索引
多对多，相亲表：两张表+一张关系表+联合唯一索引+两个外键

insert into tb12(name, age) values(***,***),(***,***)一次插入两个值
insert into tb12(name, age) select name,age from tab11

select * from tb12 where id (not) in (1,2,3,4)
where between * and *;
where name like "%a%"后面全部字符； "a_"后面一个字符
select * from tb12 limit 0起始位置, 10显示的条数
select * from tb12 order by id desc, name asc limit 10

分组：
select count(id), part_id from userinfo5 group by part_id having count(id) > 1; 聚合函数的二次筛选只能用having

左右连表：
select * from tb1, tb2笛卡尔积
select * from tb1 left join tb2 on tb1.id = tb2.name
innder join将出现null的一行隐藏

上下连表：union自动去重，union all不去重

去重：
select student_id from score where num < 60 group by student_id
select distinct student_id from score where num < 60       效率低

视图：某一组查询语句设置别名，方便日后使用

触发器：对一张表进行增删改查时，可以自定义关联行为

加速查找速度：
连表时数据类型一致
用char代替varchar
用count(1)代替count(*)
索引尽量短

组合索引：两列构成索引
最左前缀匹配：
where ***=*** and ***=*** 必须含有组合索引中最左边的列才会走索引
KEY index_col1_col2_col3 on test(col1,col2,col3);
联合索引 index_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。

索引合并：
两个索引，在查找时用and连接

不会命中索引：
like "a%"
函数
or中有未建立索引的列
类型不一致
！=
>
order by

解决慢查询：使用索引、命中索引、优化SQL语句、优化数据库对象、硬件优化、MySQL自身优化

从整体来看，一个查询要经过这么几步：
从客户端发出，半双工的形式经过网络，进入服务器，由MYSQL服务执行。
在MYSQL中首先进入查询缓存，命中之后，检查权限，跳过解析，没有命中，进入查询语句解析。
解析后的语句进入预处理，如果可以优化进行查询优化，随后进入数据库引擎执行查询计划，获得数据返回给客户端。

慢查询的优化主要涉及：MYSQL自身的优化（Schema与数据类型的优化，创建高性能的索引，查询性能优化）和MYSQL的外部优化。

1.使用索引：首先考虑在where,order by,group by 涉及的列上建立索引。
2.优化SQL语句：通过explain，可以看到SQL的执行效果，从而选择更好的索引和优化查询语句。比如：explain selext * from student。
3.查询的时候不要用 * 号。
4.不在索引列上做运算或者使用函数。
5.查询的时候尽量使用 limit 减少返回的行数。

优化数据库对象：
1.使用 procedure analyse() 函数对表进行分析。这个函数可以对表中列的数据类型提出优化建议。表的数据类型的第一个原则是，能正确表示和存储数据的最短类型。能小就小。比如：select * from student procedure analyse()。
2.分表。如果一个表中有些列常用有些不常用，就垂直拆分，即把主键和一些列放在一个表中，把主键和另外一些列放在另一个表总。如果都常用，这个一个表又太大了，那就按行拆分，大表拆小表，也叫水平拆分。
3.中间表。如果要经常对一个表进行aggregation，那么我可以把这些结果用一个中间表存起来，这个也可以理解成另一种程度的分表。
4.分区。分区就是把一个表分成多个区块，这个区块可以在一个磁盘上，也可以

良好的表的设计可以节省后期的维护成本。

数据类型优化细节：
1.如果字符串大小是一个定长的值，或者非常短的列，使用char会比varchar更有效率。
2.简单地数据类型能存储地就不要用复杂地数据类型，比如：使用时间内建类型比如DATATIME或者TIMESAMP而不是字符串存储日期和时间，整形存储IP地址等。
3.避免NULL。比如：虽然很多表都可以包含NULL，但是如果是查询NULL列的时候可能会更复杂，比如当含NULL的列被索引时，每个索引需要一个额外的



聚簇索引、覆盖索引回表，MVCC，


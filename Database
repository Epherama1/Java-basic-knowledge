脏读（读取未提交数据）
A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。

不可重复读（前后多次读取，数据内容不一致）
事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间。和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。

幻读（前后多次读取，数据总量不一致）
事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样。

不可重复读和幻读到底有什么区别呢？
(1) 不可重复读是读取了其他事务更改的数据，针对update操作
解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。
(2) 幻读是读取了其他事务新增的数据，针对insert和delete操作
解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

数据库事务的四大特性：
1、原子性：事务包含的所有数据库操作要么全部成功，要不全部失败回滚
2、一致性：一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
3、隔离性：一个事务未提交的业务结果是否对于其它事务可见。级别一般有：read_uncommit，read_commit，read_repeatable，Serializable 串行化访问。
4、持久性：一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
只有满足一致性，事务的执行结果才是正确的。
在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
事务满足持久化是为了能应对系统崩溃的情况。

MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。
MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。
设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。
如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。


数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读
大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。
Mysql的默认隔离级别就是Repeatable read。

https://cloud.tencent.com/developer/article/1450773

读写锁：互斥锁X，共享锁S。对象A加了X锁，A就不能再加任何锁，可以读取和写入。加了S锁，只能读取，在这期间A只能被加S锁，不能加X锁。
意向锁：若想对表或表中的行进行操作，需要先对该表增加意向锁XI/SI。
1.若想对整个表加X锁，检查发现有XI/SI锁，则加X锁失败。
2.任意XI/SI锁都是兼容的，两个事务可以同时对表中的两行进行操作。

封锁协议？


隔离级别：
未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。
提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的。
可串行化（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

MVCC：
多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。
而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。
在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。
读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。
https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc

NEXT-KEY-locks：
MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。


实现中文：default charset = utf8

数据类型：
数字：tinyint, bigint, int, float, double(不精确小数), decimal(总位数，小数点后几位)(精确小数，可以指定精度，用字符串存)
字符串：最多255个字符，char(10)速度快，存数据的位置是固定的，长度不够用空格填充；varchar(10)，占空间小，位置不固定；text，longtext(4GB)
时间类型：DATATIME
enum枚举类型
set集合类型

清空表：delete from table / truncate table（快得多）
删除表：drop table
delete之后再插入数据，自增主键接着之前的序号，不是从1开始
修改自增的起始点：alter table t10 AUTO_INCREMENT = 20;

可以多个列一起作为主键->多个主键列同时作为外键，primary key(nid, pid)

索引：主键索引，普通索引，唯一索引，联合索引
索引需要创建额外的文件

主键和唯一索引的区别：
1.主键是一种约束，唯一索引是一种索引
2.一张表只能有一个主键但可以有多个唯一索引
3.主键不能为null，唯一索引可以为null
4.主键可以作为外键，唯一索引不行

一对一，权限表：两张表+外键+唯一索引
多对多，相亲表：两张表+一张关系表+联合唯一索引+两个外键

insert into tb12(name, age) values(***,***),(***,***)一次插入两个值
insert into tb12(name, age) select name,age from tab11

select * from tb12 where id (not) in (1,2,3,4)
where between * and *;
where name like "%a%"后面全部字符； "a_"后面一个字符
select * from tb12 limit 0起始位置, 10显示的条数
select * from tb12 order by id desc, name asc limit 10

分组：
select count(id), part_id from userinfo5 group by part_id having count(id) > 1; 聚合函数的二次筛选只能用having

左右连表：
select * from tb1, tb2笛卡尔积
select * from tb1 left join tb2 on tb1.id = tb2.name
innder join将出现null的一行隐藏

上下连表：union自动去重，union all不去重

去重：
select student_id from score where num < 60 group by student_id
select distinct student_id from score where num < 60       效率低

视图：某一组查询语句设置别名，方便日后使用

触发器：对一张表进行增删改查时，可以自定义关联行为

加速查找速度：
连表时数据类型一致
用char代替varchar
用count(1)代替count(*)
索引尽量短

组合索引：两列构成索引
最左前缀匹配：
where ***=*** and ***=*** 必须含有组合索引中最左边的列才会走索引

索引合并：
两个索引，在查找时用and连接

不会命中索引：
like "a%"
函数
or中有未建立索引的列
类型不一致
！=
>
order by









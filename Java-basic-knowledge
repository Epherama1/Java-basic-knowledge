JVM JRE和JDK区别与联系:

JVM + 核心类库 = JRE
JRE + java开发工具（javac.exe/jar.exe) = JDK
这是因为我们是开发人员,我们是写软件的,软件光能运行不行啊,得给我们一个地方让我们来写代码吧?所以就需要java开发工具给我们腾出一个地儿来,好让我们coding

JVM:
JVM 是 Java Virtual Machine（Java虚拟机）的缩写，它是整个 java 实现跨平台的最核心的部分，所有的 java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。
JVM 是 Java 平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。
JVM 通过抽象操作系统和 CPU 结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。
JVM 的主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或对应的系统调用，保护用户免被恶意程序骚扰。

JRE:
光有 JVM 还不能让 class 文件执行，因为在解释 class 的时候 JVM 需要调用解释所需要的类库 lib。
在 JDK 的安装目录里你可以找到 jre 目录，里面有两个文件夹 bin 和 lib,在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 jvm 和 lib 和起来就称为 jre。所以，在你写完java程序编译成.class之后，你可以把这个 .class 文件和 jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。
JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。

JDK:
在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。
bin： 最主要的是编译器（javac.exe）
include： java 与 JVM 交互用的头文件
lib： 类库
jre： java 运行环境
注意：这里的bin、lib文件夹和jre里的bin、lib是不同的.

总的来说，JDK 是用于 java 程序的开发,而 jre 则是只能运行 class 而没有编译的功能。
eclipse、idea 等其他 IDE 有自己的编译器而不是用 JDK bin 目录中自带的，所以在安装时你会发现他们只要求你选jre 路径就 ok 了。

JDK，JRE，JVM 三者的联系:
jdk 是 JAVA 程序开发时用的开发工具包，其内部也有 JRE 运行环境 JRE 。JRE 是 JAVA 程序运行时需要的运行环境，就是说如果你光是运行 JAVA 程序而不是去搞开发的话，只安装 JRE 就能运行已经存在的 JAVA 程序了。JDK、JRE 内部都包含 JAVA 虚拟机 JVM，JAVA 虚拟机内部包含许多应用程序的类的解释器和类加载器等等。




MAVEN:
使之项目描述结构清晰，任何人接手的成本比较低。
而且一个项目可能依赖于其他的项目和第三方的组件才能顺利完成，Maven提供了仓库的概念，让这些依赖项放进仓库中，项目想要从仓库中去取，其他项目组也需要，OK，从仓库中去取，不必每个人去开源项目的站点去苦苦搜寻了。
通过Maven辅助管理项目，更能发现项目中哪些模块是重复的轮子。
Maven就是这个超市，只是它卖的不是红烧排骨，而是一个jar包已经和它有依赖关系的其他jar包。这样，你就不用再开撸java代码前，去各个网站下载各种不同的jar包了，也不用考虑它们之间的依赖关系。


Java SE(Java Platform,Standard Edition)，应该先说这个，因为这个是标准版本。
Java EE (Java Platform，Enterprise Edition)，java 的企业版本
Java ME(Java Platform，Micro Edition)，java的微型版本。
se写桌面应用，ee写web应用，me写移动应用。但现在me被安卓取代了。ee用的很少，用的都是在ee上面衍生出来的spring。



servlet接口定义的是一套处理网络请求的规范，所有实现servlet的类，都需要实现它那五个方法，其中最主要的是两个生命周期方法 init()和destroy()，还有一个处理请求的service()，
也就是说，所有实现servlet接口的类，或者说，所有想要处理网络请求的类，都需要回答这三个问题：你初始化时要做什么, 你销毁时要做什么, 你接受到请求时要做什么

tomcat才是与客户端直接打交道的家伙，他监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理，然后调用那个servlet的service方法，service方法返回一个response对象，tomcat再把这个response返回给客户端。

Tomcat其实是Web服务器和Servlet容器的结合体。
而Web服务器的作用说穿了就是：将某个主机上的资源映射为一个URL供外界访问。
其中接收请求和响应请求是共性功能，且没有差异性。大家就把接收和响应两个步骤抽取成Web服务器：https://pic2.zhimg.com/80/v2-3d86f470ec1dc31bbe93d1df2c30fa47_1440w.jpg?source=1940ef5c
但处理请求的逻辑是不同的。没关系，抽取出来做成Servlet，交给程序员自己编写。
随着后期互联网发展，出现了三层架构，所以一些逻辑就从Servlet抽取出来，分担到Service和Dao。
但是Servlet并不擅长往浏览器输出HTML页面，所以出现了JSP。

JSP全称Java Server Page，直译就是“运行在服务器端的页面”。
服务器内部会经历一次动态资源（JSP）到静态资源（HTML）的转化，服务器会自动帮我们把JSP中的HTML片段和数据拼接成静态资源响应给浏览器。
也就是说JSP运行在服务器端，但最终发给客户端的都已经是转换好的HTML静态页面（在响应体里）。服务器并没有把JSP文件发给浏览器。
JSP = HTML + Java片段（各种标签本质上还是Java片段）
JSP本质是一个Java类（Servlet），是在服务器混的，只不过它输出结果是HTML。
JSP就是一个Servlet

从Tomcat开始，我们再也没写过main方法。以前，一个main方法启动，程序间的调用井然有序，我们知道程序所有流转过程。
框架就像一个傀儡师，我们写的程序是傀儡，顶多就是给傀儡化化妆、打扮打扮，实际的运作全是傀儡师搞的。

其实请求、响应这么一来一回，无非要的就两样东西：数据+HTML骨架。
1.卖家组装好商品后再发货（JSP）
2.卖家把部件拆开，运到之后买家自己组装（AJAX+HTML）
JSP是服务器端的，它的局限性在于数据必须在返回给客户端之前就“装载”完毕。不然HTML都已经发出去了，你就没办法跑到浏览器里把数据给它安上。而有了AJAX，就可以实现零件发送、目的地组装了。


项目一：
通过tomcat和serverlet做的一个类似大众点评的一个工作搜索网站。可以注册、登录，搜索感兴趣的工作，根据搜索历史自动推荐工作，并实现收藏功能。
通过session实现登陆和注册，在后端通过HTTPClient实现一个虚拟客户端来调用GitHubJOB API来获得工作推荐。通过获取所有收藏历史并进行关键词提取来搜索实现自动推荐。
The first one is a SearchItems API that provides the functionality to search around, 
The second servlet that allows a user to set or unset their favorite records. 
The last one that recommends similar items to the user. 
用JDBC操作数据库
数据库：
users - store user information.

items - store item information.

keyword - store item-keyword relationship：
Primary key = item_id + keyword 
Foreign key = item_id => items(item_id)

history - store user favorite history：
Primary key = item_id + user_id
Foreign key = user_id => users(user_id)
Foreign key = item_id => items(item_id)

Primary key: Also a key that is unique for each record. It cannot be NULL and used as a unique identifier.
Foreign key: a key used to link two tables together. A FOREIGN KEY is a field (or collection of fields) in one table that refers to the PRIMARY KEY in another table.

Why do we need a session?
The HTTP protocol and Web Servers are stateless, what it means is that for a web server every request is a new request to process and they can’t identify if it’s coming from a client that has been sending requests previously. 


RPC(Remote Procedure Call): a function call to a remote server. 
Java Servlet: Java class to handle RPC on the server-side.
Tomcat is an environment to run your web service, it provides low-level support such as making TCP connections, 
receiving requests from clients, finding the correct service to handle that request, and sending a response back.

Normally we don’t return static HTML code to the front end directly because it should be created by a front-end developer. 
We just need to return the correct data that should be displayed by the frontend. In our project, we’ll use JSON as for body format.

because we’re using some features only available in JavaSE-1.8+。 //what kind of features?
Open pom.xml file, set java version and add Tomcat library as dependency of your project. 

写的Java程序存放在src/main/java/rpc，但需要在servelet-mapping建立映射


JSON: JavaScript Object Notation(JavaScript 对象表示法)
省空间，基本没浪费的字符。标准，主流都用它。语言无关。类型安全。
response.setContentType("application/json"); //设置数据类型

response.getWriter()的作用
PrintWriter out = response.getWriter();
getWriter()返回一个PrintWriter object
但是为什么用response呢？而不是new一个PrintWriter对象呢？
 
答：
代码首句的意思是拿到流（可以理解为管道）对象，而非response这个实体，他拿到了PrintWriter这个类的字符流对象，然后对流进行操作。
PrintWriter类是Writer类的子类。
你做的操作的结果应该想要反映到response对应的位置，于是你要拿到属于response的流，而不是new一个出来。
这里的out对象是从Web容器中获取到的，而不是你新创建的，web容器加载servlet的时候已经为您创建好了out对象，你只要获取到然后使用就可以了！

JSONArrray is the structure that contains a series of JSONObject.

HTML - 页面结构
CSS - 页面的样式表现
JavaScript - 交互行为


HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包。
HTTP Client和浏览器有点像，都可以用来发送请求，接收服务端响应的数据。但它不是浏览器，没有用户界面。HttpClient是一个HTTP通信库，只通过其API用于传输和接受HTTP消息。

P161：为什么要引入Httpclient？他的作用是什么？之前的serverletresponse为什么不继续用了？：
为了在后端实现客户端的角色。在后端充当客户端角色给其他的后端发送http请求。
client(前端) -> serverlet -> Github client -> Github server
serverlet和GitHub client可以合在一起
一个httpclient可以发送多个请求

Example1：
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpGet = new HttpGet("http://targethost/homepage");
CloseableHttpResponse response1 = httpclient.execute(httpGet);

try {
    System.out.println(response1.getStatusLine()); //判断状态是否正确
    HttpEntity entity1 = response1.getEntity();    //读取http response的body

    // do something useful with the response body
    // and ensure it is fully consumed
    EntityUtils.consume(entity1);    //如果是发送两个请求，则第一个请求发送完要调用一下consume
} finally {
    response1.close();
}

Example2:自带garbage collection（consume and close）
CloseableHttpClient httpclient = HttpClients.createDefault();

try {
    HttpGet httpget = new HttpGet("http://httpbin.org/");
    System.out.println("Executing request " + httpget.getRequestLine());

    // Create a custom response handler
    ResponseHandler<String> responseHandler = new ResponseHandler<String>() {

        @Override
        public String handleResponse(
                final HttpResponse response) throws ClientProtocolException, IOException {
            int status = response.getStatusLine().getStatusCode();
            if (status >= 200 && status < 300) {
                HttpEntity entity = response.getEntity();
                return entity != null ? EntityUtils.toString(entity) : null;
            } else {
                throw new ClientProtocolException("Unexpected response status: " + status);
            }
        }

    };

    String responseBody = httpclient.execute(httpget, responseHandler);
    System.out.println("----------------------------------------");
    System.out.println(responseBody);
} finally {
    httpclient.close();
}

iimplement：
public JSONArray search(double lat, double lon, String keyword) {  //根据给出的地理位置和关键词，以Jason array的形式返回response的body
		if (keyword == null) {
			keyword = DEFAULT_KEYWORD;
		}
		try {
			keyword = URLEncoder.encode(keyword, "UTF-8");  //url中空格是特殊字符，url不支持，需要转码，浏览器会自动转换。但是这个是一个充当client的后台程序，但这就需要自己写转码的程序.若URL中出现空格，则空格后的内容等于没有，只按空格前的内容搜索。
		} catch (UnsupportedEncodingException e) {   //点击surround with try/catch
			e.printStackTrace();
		}
		String url = String.format(URL_TEMPLATE, keyword, lat, lon); //匹配template里的%s
		
		CloseableHttpClient httpclient = HttpClients.createDefault();  //定义httpclient

	    // Create a custom response handler
	    ResponseHandler<JSONArray> responseHandler = new ResponseHandler<JSONArray>() {   //都设置为JSONArray

	        @Override
	        public JSONArray handleResponse(                             //都设置为JSONArray
	                final HttpResponse response) throws IOException {
	            if (response.getStatusLine().getStatusCode() != 200) {   //判断response是否返回正确
	            	return new JSONArray();                                 //不正确的话就直接返回一个长度为0的JSONArray
	            }
	            HttpEntity entity = response.getEntity();                //判断body是否为空
	            if (entity == null) {
	            	return new JSONArray();
	            }
	            String responseBody = EntityUtils.toString(entity);      //把body转成string格式
	            return new JSONArray(responseBody);                      //把string变成JASONArray
	        }
	    };
	    
		try {
			return httpclient.execute( new HttpGet(url), responseHandler);
		} catch (ClientProtocolException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}

		return new JSONArray();
	}
 
update doGet():
import external.GitHubClient;

public class SearchItem extends HttpServlet {
      ...
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		double lat = Double.parseDouble(request.getParameter("lat"));
		double lon = Double.parseDouble(request.getParameter("lon"));

		GitHubClient client = new GitHubClient();
		RpcHelper.writeJsonArray(response, client.search(lat, lon, null)); //把client search的结果写到要返回的response中
	}


entity：数据清理之后的数据结构
设置一个Item类，并写好让外界访问的API：getter

实现可以将某些参数不初始化来定义一个对象：
builder.setItemId("abcd");
Item item = builder.build();

public static class ItemBuilder {
		private String itemId;
		private String name;
		private String address;
		private String imageUrl;
		private String url;
		private Set<String> keywords;

		public void setItemId(String itemId) {
			this.itemId = itemId;
		}

		public void setName(String name) {
			this.name = name;
		}

		public void setAddress(String address) {
			this.address = address;
		}

		public void setImageUrl(String imageUrl) {
			this.imageUrl = imageUrl;
		}

		public void setUrl(String url) {
			this.url = url;
		}

		public void setKeywords(Set<String> keywords) {
			this.keywords = keywords;
		}

		public Item build() {          //要传的参数传完后，最后调用一次build()一起初始化
			return new Item(this);
		}
	}


getString()用法？啥时候用？
List<List<String>> keywords = MonkeyLearnClient.extractKeywords(descriptionList.toArray(new String[descriptionList.size()])); //把List转化成Array
Set没有order，List有Order

应用JDBC在Java中操作数据库
table之间是有联系的，要按一定顺序建立和删除

Primary key：不能为空，不能重复，可以两列绑在一起作为一个primary key，会自动创建索引 null和null不算重复
Foreign key：指向另一个table中的某一列（Primary Key），保证在子table中插入时，某个用户已经在父table里存在。若没有Primary Key，可以声明父table某一列为unique

INSERT INTO history (user_id, item_id) VALUES (?, ?）在userid和itemid的列中插入value对应的数据

若一个class中全都是static方法，不想被别人用来构建对象，可以设置一个私有的构造函数

Apache commons IO
IOUtils.toString

ResultSet:元素为object的set。有个iterator指向第-1个元素，通过next遍历 6.7/1.30

The session object is stored on the server side, only session ID is returned to the client side.
When a user logs out, the session is destroyed. Next time a user comes, he/she has to authenticate again to get a new session.

session和cookie的区别：？？？

logout一般写在post里，有些浏览器会提前cache doGet的内容，这样会导致直接logout

recommendation algorithm：lesson16 6.10

EC2 VM docker deploy：Lesson13 + Lesson19 6.14 14.00
Setup MySQL on Amazon RDS
Amazon Web Service(AWS) Introduction
Amazon Elastic Compute Cloud(EC2)
Elastic Compute Cloud (EC2) allows scalable deployment of applications by providing a Web service through which a user can boot an Amazon Machine Image to create a virtual machine, which Amazon calls an "instance", containing any software desired. 
A user can create, launch, and terminate server instances as needed, paying by the hour for active servers, hence the term "elastic".
Amazon Relational Database Service(RDS)
security group：firewall

数据库建立：先通过EC2建立一个security group，在RDS配置中与之关联
虚拟机建立：launch EC2，设置security group，下载key pair，用命令行从本地连接到虚拟机

Docker：container service
Bins：程序编译后的二进制代码
LIBS：library库
虚拟机上只跑一个程序有点浪费，若跑多个程序，程序之间无法实现百分百隔离，多个人访问同一个虚拟机会有安全漏洞，内存可能重叠
docker实现两个程序的完全隔离
程序的运行可能并不需要OS所有的资源，在这种情况给其配置整个操作系统就有点浪费。在每个docker中，可以有选择的只配置特定资源避免浪费。
EC2配置虚拟机，在虚拟机上运行docker跑程序
dockerfile：标明了此docker中要包含什么：基础资源和要运行的程序
先以当前路径下的dockerfile作为蓝本build一个docker镜像（image），每运行一次这个镜像就会生成一个container，每个镜像里的内容一样
虚拟机的端口号和docker的端口号可以不一样，可以在运行docker的时候相互对应上

Summery ：Lesson20 6.15


项目二：
类似微博同城的一个web实现。包括三个API：post, search, and cluster。可以发布分享自己的媒体文件或者查看自己周围一定区域的其他人的分享。后端部署在谷歌的GKE上，媒体文件储存在GCS上，
发布的留言评论存储在ElacticSearch上。GKE是谷歌提供的虚拟机。GCS相当于网盘或者文件系统用来存储媒体文件。ElasticSearch用来存评论的数据库。

为什么不存在一起？数据库不适合存储大型二进制对象。1.之所以要存在数据库是为了结构化数据方便查找和更新。2.无论数据还是媒体文件最终都会通过文件系统存储在磁盘，若存储媒体文件时还要通过一层数据库，
会增加不必要的数据库开销，增加数据库体积会使得维护性变差。3.GCS通过CDN（内容分发网络，负载均衡、内容分发、调度，比如通过位置判断哪个数据库离你最近，就让你访问该数据库而不是总数据库）来降低访问延迟。
两个存储位置如何关联？数据库中存GCS中每一个文件对应的独立网址。

I use JSON Web Token for server authentication. 

为什么选ElasticSearch？自带的地理索引功能强大，二维表格，Key-value pair，经纬度索引，k-d tree（类似二分搜索树）；为了练习一下使用非关系型数据库；同在Google平台，相互兼容性好
8080：go程序测试使用
9200: ElasticSearch测试使用
Go比C慢：garbage collector，GC的时候有一部分没法执行。
Go的主要用途：并发机制

I use Go to build a web service that has three main APIs: post, search, and cluster. 
The post API allows users to submit a post that can include a message, geolocation, and media file. 
The search API allows users to search nearby posts based on their current location. 
The cluster API allows users to find all posts whose media file is a photo of a face.
Google Cloud has a large collection of some great tools and services which provide the features required by my project, such as GCE, GCS, GKE, Cloud Vision API



GKE：Lesson22 6.20
How do you use GKE?
I use GKE to deploy my Go service. I build my program into a docker image and run the image on virtual machines managed by my GKE cluster.  

Why do you use GKE?
I use GKE because it can help to make my service run in a cluster with multiple virtual machines, which improved the reliability of my service. Since my service is running on multiple virtual machines, a single failure of one virtual machine won’t affect the whole service.
租虚拟机instance部署自己的service和亚马逊EC2类似
GKE可以管理许多台虚拟机instance，可以对这多台虚拟机进行分类和管理；而且可以实现不同虚拟机台数的自动切换，用户多就多一些，用户少就少一些；自带负载均衡器，保证每台虚拟机上的负载相差不大。
但EC2只能在一台上，如果需要多台，则必须一台一台部署
管理单台虚拟机：GCE = EC2

ElasticSearch：
存储用户的message（留言评论）
搜索强大，根据要求可以自主建立各种各样的index，对不同的数据类型有不同形式的优化
非关系型数据库，二维表格，key-value pair数据

GCS：
网盘，相当于文件系统，在线存储文件，储存用户上传的媒体文件。
1.数据库不适合存储视频和照片：媒体文件用不到数据库的各种功能。数据库功能：结构化存储数据方便查找和更新。
2.数据库存储数据：数据库 -> 文件系统（操作系统）-> 磁盘。若绕开数据库，直接通过文件系统存入磁盘，则数据库的开销就可以省去了。
都运行在Google cloud平台上，兼容性好
如何将媒体文件和留言相关联：GCS中每一个文件都对应一个独立的网址，把该网址存入到ElasticSearch中

Firewall：
控制虚拟机的访问权限：谁能向虚拟机发请求以及请求都发到哪个端口。0.0.0.0/0向所有用户敞开。
tcp：
8080：go程序测试使用
9200: ElasticSearch测试使用

Use tmux to handle disconnection

Go语言的并发机制
图灵完整
C和C++直接编译成机器语言machine code，可以直接在cpu上运行，内存管理由程序员控制->效率高，可能内存泄漏。smart point智能指针自动释放。
Java有garbage collector
两种数据类型可以任意转换不需要转换函数，隐式转换 ：弱类型。python不是，python是动态类型，随意绑定。
Java编译成byte code。JIT，just in time 直接到machine code。Java静态语言，可以优化。
Go编译型语言，Java和python解释型语言。
Go比C慢：garbage collector，GC的时候有一部分没法执行。
Go的主要用途：并发机制
package：Java，python，go。可见性的控制，package内部可见，不用import。//那同一个package内，不同class之间可以互相访问private的元素吗？

首字母是否大写：public，外部可访问
类型名在变量的后面
Java中：SomeClass var = GetObject() 将var这个变量绑定一个对象 ；C++中：SomeClass* var = GetObject()
多个返回值：
func swap(x, y string) (string, string) {
	return y, x
}
给返回值绑定一个名字，然后直接返回
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
声明变量：若不赋值则有默认值，零假空
var i int

自动判断是否是在初始化：简化写法，但不能在函数外这么写
k ：= 3；
i := 42
f := float64(i)
u := uint(f)
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128

%v可以绑定任何类型的值

常量：const Pi = 3.14

可以给常量一个非常大的整数，超过64位
Big = 1 << 100：将1往左移动100位
Small = Big >> 99：将Big往右移动99位

int32，int64，int128，明确标注

For loop：
for循环不用加括号
for i := 0; i < 10; i++ {
		sum += i
	}
while通过for实现：
for sum < 1000 {
		sum += sum
while(true):
for {
	}

if不用加括号
可以在if前声名变量，保证其作用域在if内：
if v := math.Pow(x, n); v < lim {
		return v
	}

Switch：
可以匹配string，Java也可以匹配string，C不能匹配string
Go的switch中没有break语句
//fallthrough是啥？

Switch当成else if用：
func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}

Defer：
离开作用域的时候执行
func main() {
	defer fmt.Println("world")

	fmt.Println("hello")     //defer：fmt.Println("hello")是个栈
}
用来释放资源：defer f2.Close()，保证离开作用域必定执行。先执行后面的defer，再执行前面的：栈。因为可能后面的要依赖前面的资源。
//Java的yield是啥？
	}
	
指针：
p := &i         // point to i 把i的地址赋给p
fmt.Println(*p) // read i through the pointer 
*p = 21         // set i through the pointer 取以p位地址的值
fmt.Println(i)  // see the new value of i     i变成21了

struct：
type Vertex struct {
	X int
	Y int
}
func main() {
	fmt.Println(Vertex{1, 2})直接初始化struct
}
func main() {
	v := Vertex{1, 2}
	v.X = 4       在外面访问struct的内部元素

指针struct：
func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9
	fmt.Println(v)
}

var (
	v1 = Vertex{1, 2}  // has type Vertex
	v2 = Vertex{X: 1}  // Y:0 is implicit
	v3 = Vertex{}      // X:0 and Y:0
	p  = &Vertex{1, 2} // has type *Vertex
)

数组是定长的：
func main() {
	var a [2]string
	a[0] = "Hello"
	a[1] = "World"
	fmt.Println(a[0], a[1])
	fmt.Println(a)

	primes := [6]int{2, 3, 5, 7, 11, 13}
	fmt.Println(primes)
}

Slice：不定长
func main() {
	primes := [6]int{2, 3, 5, 7, 11, 13}
	var s []int = primes[1:4]    //[)
	fmt.Println(s)
}

浅复制和深复制：
浅：指向同一个内存区间，改一个，另一个也变
深：不同内存区间但值一样

func main() {
	s := []int{2, 3, 5, 7, 11, 13}

	s = s[1:4]
	fmt.Println(s)

	s = s[:2]
	fmt.Println(s)

	s = s[1:]
	fmt.Println(s)
}

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
)

type Location struct {
        Lat float64 `json:"lat"`
        Lon float64 `json:"lon"`
}

type Post struct {
        User     string   `json:"user"`    //相当于转换时的说明，一一对应转换
        Message  string   `json:"message"`
        Location Location `json:"location"`
        Url      string   `json:"url"`
        Type     string   `json:"type"`
        Face     float32  `json:"face"`
}

func main() {
        fmt.Println("started-service")
        http.HandleFunc("/post", handlerPost)  //将函数与请求绑定：若url中是post请求，则调用handlerPost这个函数来处理这个请求
        log.Fatal(http.ListenAndServe(":8080", nil))    //作用？6.20 14:00
}

//练习版handlerpost
func handlerPost(w http.ResponseWriter, r *http.Request) {     //serverlet类似，处理http request并将结果写入response    这是干啥用的？
        // Parse from body of request to get a json object.
        fmt.Println("Received one post request")
        decoder := json.NewDecoder(r.Body)       //准备把Json的数据转换为其他格式
        var p Post                               //Go数据格式
        if err := decoder.Decode(&p); err != nil {     //转换
                panic(err)
        }

        fmt.Fprintf(w, "Post received: %s\n", p.Message)     //对w做了什么处理？6.20 14:00
}


sudo vim /etc/elasticsearch/elasticsearch.yml
discovery.type: single-node   //不以分布式来运行
ElasticSearch运行端口：9200

为什么选internalIP而不选externalIP？每次重启虚拟机internalIP不改变，外部IP为什么变？IP地址有限
const (
        POST_INDEX = "post"
        ES_URL = "http://YOUR_GCE_INTERNAL_IP_ADDRESS:9200"
)
func main() {
        client, err := elastic.NewClient(elastic.SetURL(ES_URL)) //与数据库建立连接，ES_URL是数据库的网址加端口号，返回两个值，err用来判断是否有错误发生，若运行在同一台虚拟机上localhost也可以，但以防万一不在一台虚拟机上
        if err != nil {
                panic(err)
        }

        exists, err := client.IndexExists(POST_INDEX).Do(context.Background())     //Index就是database，判断数据库POST_INDEX是否存在
                                                                                   //前面是提供参数，Do是真正执行，.Background:空白，没有额外信息
        if err != nil {                                                            //IndexExists是对于ElasticSearch的http请求，context该请求是否有额外参数（提前终止），请求处理的过程转变为Go routine，参数传给Go routine
                panic(err)
        }
        if !exists {	
                mapping := `{    //database的蓝图schema
			”settings“:{
				"number_of_shards":1,    //切片存储
				"number_of_replicas":0   //备份
			}
                        "mappings": {
                                "properties": {  //列
                                        "user":     { "type": "keyword", "index": false },  //数据类型，是否建立索引
                                        "message":  { "type": "keyword", "index": false },  //keyword：string
                                        "location": { "type": "geo_point" },                //geo_point:自动建立2-d树来进行range search
                                        "url":      { "type": "keyword", "index": false },
                                        "type":     { "type": "keyword", "index": false },
                                        "face":     { "type": "float" }
                                }
                        }
                }`
                _, err := client.CreateIndex(POST_INDEX).Body(mapping).Do(context.Background())   //创建数据库
                if err != nil {
                        panic(err)
                }
        }
        fmt.Println("Post index is created.")
}
ElasticSearch本来是有table的概念叫type，但ElasticSearch有个bug，他每个type内不能有同名的列，bug修不好，不能重复也就没必要多个table了，所以没有table这个概念

如何用Go操作ElasticSearch：如何search

//教程
// Search with a term query
ctx := context.Background()
termQuery := elastic.NewTermQuery("user", "olivere")    //以什么样的限制条件去数据库中找数据，找user=olivere的数据，Term：关键词搜索法
searchResult, err := client.Search().                   //searchResult存放返回的数据
    Index("twitter").   // search in index "twitter"
    Query(termQuery).   // specify the query            //确定检索限制条件
    Sort("user", true). // sort by "user" field, ascending
    From(0).Size(10).   // take documents 0-9
    Pretty(true).       // pretty print request and response JSON
    Do(ctx)             // execute                      //Do返回的就是一个pointer指针
if err != nil {
    // Handle error
    panic(err)             //Panic会使得程序停止执行，但没必要，只要告知前端出错即可，特殊情况内存泄漏死锁可以听下程序
}

fmt.Printf("Query took %d milliseconds\n", searchResult.TookInMillis)    //debug

var ttyp Tweet      //Tweet是个struct，ttyp是个Tweet类型的变量            //返回index和value两个参数，不关心index就用_代替
for _, item := range searchResult.Each(reflect.TypeOf(ttyp)) {      //把searchResult中所有的搜索结果检查一下哪一些是能转换成ttyp类型的，把满足条件数据进行循环内操作（转换成ttyp），为了安全地转换
    t := item.(Tweet)       //把item对象转换为Tweet对象
    fmt.Printf("Tweet by %s: %s\n", t.User, t.Message)
}
unmarshal:把Jason格式的数据转变为Go的struct
func(t):深复制
func（&t）：浅复制，执行完func，t会跟着改变

//根据搜索条件query选择出返回值（指针类型）
func readFromES(query elastic.Query, index string) (*elastic.SearchResult, error) {   
        client, err := elastic.NewClient(elastic.SetURL(ES_URL))
        if err != nil {
                return nil, err
        }

        searchResult, err := client.Search().
                Index(index).                  //在哪一个index（database）中
                Query(query).
                Pretty(true).
                Do(context.Background())
        if err != nil {
                return nil, err
        }

        return searchResult, nil
}

//将search的返回值转化为之前定义的目标结构体
func getPostFromSearchResult(searchResult *elastic.SearchResult) []Post {       
        var ptype Post
        var posts []Post

        for _, item := range searchResult.Each(reflect.TypeOf(ptype)) {
                p := item.(Post)
                posts = append(posts, p)
        }
        return posts
}

//根据request中的信息在数据库中进行搜索，并将结果写入到response中返回
func handlerSearch(w http.ResponseWriter, r *http.Request) {
        fmt.Println("Received one request for search")

        w.Header().Set("Content-Type", "application/json")     //通过在header加一个key-value pair告诉前端返回的数据类型是什么

        lat, _ := strconv.ParseFloat(r.URL.Query().Get("lat"), 64)   //r.URL.Query()得到的是url中？后面的内容，类型是string，再把string转换成64位的float
        lon, _ := strconv.ParseFloat(r.URL.Query().Get("lon"), 64)
        // range is optional
        ran := DISTANCE      //默认搜索范围string
        if val := r.URL.Query().Get("range"); val != "" {  //若前端发来搜索范围则使用发来的，val只在if的作用域内有效
                ran = val + "km"        //搜索参数要加一个单位
        }
        fmt.Println("range is ", ran)

        query := elastic.NewGeoDistanceQuery("location")   //按照location距离搜索
        query = query.Distance(ran).Lat(lat).Lon(lon)      //对location的限制条件，在lat和lon确定的点以ran为半径搜索
        searchResult, err := readFromES(query, POST_INDEX)
        if err != nil {
                http.Error(w, "Failed to read post from Elasticsearch", http.StatusInternalServerError)  //返回http的错误写入response内，http.StatusInternalServerError是返回错误代码
                fmt.Printf("Failed to read post from Elasticsearch %v.\n", err)
                return
        }
        posts := getPostFromSearchResult(searchResult)

        js, err := json.Marshal(posts)    //把Go的struct变成Jason数据
        if err != nil {
                http.Error(w, "Failed to parse posts into JSON format", http.StatusInternalServerError)
                fmt.Printf("Failed to parse posts into JSON format %v.\n", err)
                return
        }
        w.Write(js)
}

//教程
func main() {
        ctx := context.Background()

        // Sets your Google Cloud Platform project ID.
        projectID := "YOUR_PROJECT_ID"

        // Creates a client.
        client, err := storage.NewClient(ctx)     //GCS创建client
        if err != nil {
                log.Fatalf("Failed to create client: %v", err)
        }

        // Sets the name for the new bucket.
        bucketName := "my-new-bucket"

        // Creates a Bucket instance.
        bucket := client.Bucket(bucketName)       //在GCS中创建bucket（文件夹）

        // Creates the new bucket.
        if err := bucket.Create(ctx, projectID, nil); err != nil {   //nil:地区的选择，property的设置都是默认选项
                log.Fatalf("Failed to create bucket: %v", err)
        }

        fmt.Printf("Bucket %v created.\n", bucketName)
}

func write(client *storage.Client, bucket, object string) error {
	ctx := context.Background()
	// [START upload_file]
	f, err := os.Open("notes.txt")   //打开一个文件
	if err != nil {
		return err
	}
	defer f.Close()

	wc := client.Bucket(bucket).Object(object).NewWriter(ctx)  //创建一个将文件写入Object的流
	if _, err = io.Copy(wc, f); err != nil {    //将刚才读入的文件复制到流中
		return err
	}
	if err := wc.Close(); err != nil {
		return err
	}
	// [END upload_file]
	return nil
}

//项目代码
//把媒体文件存储在GCS中并返回url
func saveToGCS(r io.Reader, objectName string) (string, error) {    //r：要存储的文件；objectName：网盘中object的名字；string：图片或视频存储成功后返回的检索链接
        ctx := context.Background()
        client, err := storage.NewClient(ctx)
        if err != nil {
                return "", err
        }

        bucket := client.Bucket(BUCKET_NAME)         //创建一个bucket对象，可以用其创建新的bucket或者传入数据
        if _, err := bucket.Attrs(ctx); err != nil {  //通过读取bucket的attribute判断bucket是否已经创建过
                return "", err                        //若不存在则返回错误
        } 

        object := bucket.Object(objectName)         //在文件夹中创建一个名为objectName的文件
        wc := object.NewWriter(ctx)                 //写文件的流
        if _, err := io.Copy(wc, r); err != nil {     //相当于_, err := io.Copy(wc, r)；if err != nil {}
                return "", err
        }

        if err := wc.Close(); err != nil {
                return "", err
        }
	
	//ACL：access control。通过service account实现不同组之间的交互，运行在GCE上的Go程序要访问GCS，通过GCE虚拟机对应的service account。默认只有创建者的service account可以访问，单位了使前端也可以访问URL，需要更改权限
        if err := object.ACL().Set(ctx, storage.AllUsers, storage.RoleReader); err != nil {   //storage.RoleReader读取权限，但没有其他权限；storage.AllUsers所有用户可以读其他用户上传的文件，但只能对自己上传的文件操作  
                return "", err                                                                //但bucket的所有者可以对其中所有的文件操作
        }

        attrs, err := object.Attrs(ctx)     //通过Attribute找到需要返回的链接
        if err != nil {
                return "", err
        }

        fmt.Printf("Image is saved to GCS: %s\n", attrs.MediaLink)
        return attrs.MediaLink, nil         //通过Attribute找到需要返回的链接
}

//vision.go

package main

import (
        "context"
        "fmt"
        vision "cloud.google.com/go/vision/apiv1"  //重命名为vision
)

//判断一张照片里有人脸的概率
// Annotate an image file based on Cloud Vision API, return score and error if exists.
func annotate(uri string) (float32, error) {    //人脸概率float32，GCE内部操作使用的是internal url，内部操作协同工作比较简单
        ctx := context.Background()
        client, err := vision.NewImageAnnotatorClient(ctx)
        if err != nil {
                return 0.0, err
        }
        defer client.Close()

        image := vision.NewImageFromURI(uri)    //通过url读取文件，内部操作协同工作比较简单
        annotations, err := client.DetectFaces(ctx, image, nil, 1)   //返回detect结果
        if err != nil {
                return 0.0, err
        }
        if len(annotations) == 0 {
                fmt.Println("No faces found.")
                return 0.0, nil
        }
        return annotations[0].DetectionConfidence, nil    //DetectionConfidence得到第一个人脸对应的概率
}

HTTP Multipart Request
An HTTP multipart request is an HTTP request that HTTP clients construct to send files and data over to an HTTP Server. 
It is commonly used by browsers and HTTP clients to upload files to the server. 
The content-type "multipart/form-data" should be used for submitting forms that contain files, non-ASCII data, and binary data.


import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
    "path/filepath"     //通过文件后缀判断是图片还是视频
    "reflect"
    "strconv"

    "cloud.google.com/go/storage"
    "github.com/olivere/elastic"
    "github.com/pborman/uuid"
)
var (        //不同的后缀映射成不同的文件类型
        mediaTypes = map[string]string{    //HashMap
                ".jpeg": "image",
                ".jpg":  "image",
                ".gif":  "image",
                ".png":  "image",
                ".mov":  "video",
                ".mp4":  "video",
                ".avi":  "video",
                ".flv":  "video",
                ".wmv":  "video",
        }

//把用户发布的post信息存储在数据库中
func saveToES(post *Post, index string, id string) error {
        client, err := elastic.NewClient(elastic.SetURL(ES_URL))
        if err != nil {
                return err
        }

        _, err = client.Index().   //往数据库中存数据的API index相当于insert
                Index(index).
                Id(id).                   //primary key
                BodyJson(post).           //BodyJson是什么？
                Do(context.Background())

        if err != nil {
                return err
        }
	
        fmt.Printf("Post is saved to index: %s\n", post.Message)
        return nil
}

//处理用户新发布的post：0.Read parameter from client 1.save image to GCS 2.annotate image with vision api 3.save post to ES
func handlerPost(w http.ResponseWriter, r *http.Request) {
        fmt.Println("Received one post request")
        w.Header().Set("Content-Type", "application/json")
	
	//Read parameter from client
        lat, _ := strconv.ParseFloat(r.FormValue("lat"), 64)  //参数的读取不是通过URL，而是通过body，格式上也不是Json数据，是form data的格式，因为参数内既有文字也有文件
        lon, _ := strconv.ParseFloat(r.FormValue("lon"), 64)  //FormValue是用来提取form data中的value

        p := &Post{                          //通过目前已知的参数初始化一个post对象（要存在数据库中的结构体），不知道的部分先空着
                User:    r.FormValue("user"),
                Message: r.FormValue("message"),
                Location: Location{          //Location是开始自己建的结构体
                        Lat: lat,
                        Lon: lon,
                },
        }
  	//save image to GCS
        file, header, err := r.FormFile("image")  //得到文件内容和文件属性，//FormFile是用来提取form data中的file
        if err != nil {
                http.Error(w, "Image is not available", http.StatusBadRequest)
                fmt.Printf("Image is not available %v\n", err)
                return
        }

        suffix := filepath.Ext(header.Filename)   //通过filepath.Ext得到文件后缀
        if t, ok := mediaTypes[suffix]; ok {
                p.Type = t
        } else {
                p.Type = "unknown"
        }

        id := uuid.New()                          //为了得到一个unique的ID给Object作为名字
        mediaLink, err := saveToGCS(file, id)
        if err != nil {
                http.Error(w, "Failed to save image to GCS", http.StatusInternalServerError)
                fmt.Printf("Failed to save image to GCS %v\n", err)
                return
        }
        p.Url = mediaLink   //填充要存在数据库中的结构体p中对应url的部分
	
	//annotate image with vision api
        if p.Type == "image" {               //判断必须是图片才能识别
                uri := fmt.Sprintf("gs://%s/%s", BUCKET_NAME, id)    //刚才只得到了一个external ip，为了使用internal ip（uri），手动拼接一个 //Sprintf赋值给前面的变量uri
                if score, err := annotate(uri); err != nil {
                        http.Error(w, "Failed to annotate image", http.StatusInternalServerError)
                        fmt.Printf("Failed to annotate the image %v\n", err)
                        return
                } else {
                        p.Face = score
                }
        }
//为什么不直接返回uri而要返回url，这使得在进行人脸识别时还要进行一次手动转换？因为url真正的目的是提供给前端访问图片的，前端不一定也运行在GCE中，若变成uri前端则无法访问。
//人脸识别只是一个附属功能

        //save post to ES
        err = saveToES(p, POST_INDEX, id)  //P：要存储的数据，POST_INDEX：存在哪一个数据库里，ID：unique id
        if err != nil {
                http.Error(w, "Failed to save post to Elasticsearch", http.StatusInternalServerError)
                fmt.Printf("Failed to save post to Elasticsearch %v\n", err)
                return
        }
}


//之前按经纬度检索，现在按人脸出现的概率检索
func handlerCluster(w http.ResponseWriter, r *http.Request) {
        fmt.Println("Received one cluster request")
        w.Header().Set("Content-Type", "application/json")

        term := r.URL.Query().Get("term")
        query := elastic.NewRangeQuery(term).Gte(0.9)     //只有query不一样

        searchResult, err := readFromES(query, POST_INDEX)
        if err != nil {
                http.Error(w, "Failed to read from Elasticsearch", http.StatusInternalServerError)
                return
        }

        posts := getPostFromSearchResult(searchResult)
        js, err := json.Marshal(posts)
        if err != nil {
                http.Error(w, "Failed to parse post object", http.StatusInternalServerError)
                fmt.Printf("Failed to parse post object %v\n", err)
                return
        }
        w.Write(js)
}

目前无法区别get请求还是post请求，一个handler对应一个/****

    r := mux.NewRouter()       //通过第三方库来实现post、get分离，若不匹配则返回http 405

    r.Handle("/post", http.HandlerFunc(handlerPost)).Methods("POST", "OPTIONS")
    r.Handle("/search", http.HandlerFunc(handlerSearch)).Methods("GET", "OPTIONS")
    r.Handle("/cluster", http.HandlerFunc(handlerCluster)).Methods("GET", "OPTIONS")

    log.Fatal(http.ListenAndServe(":8080", r))

//前后端程序都存在EC2里，但现实生活中可能存在不同的地方
每一个handler都要加这一部分：
w.Header().Set("Access-Control-Allow-Origin", "*")  //后端通过header告诉前端是否允许其跨域访问，*代表允许所有，或者只写前端的domain
    w.Header().Set("Access-Control-Allow-Headers", "Content-Type,Authorization")    //

    if r.Method == "OPTIONS" {     //发送真正的请求之前，通过发送一条option请求来查看后端是否允许跨域访问（是否返回w.Header().Set("Access-Control-Allow-Origin", "*")），类似于握手
        return                      //浏览器知道什么时候该发option还是get
    }

Session-Based Authentication
How it works
后端只返回session ID给前端
A user enters their login credentials (username + password).
The server verifies the credentials are correct and creates a session which is then stored in a database.
Client-side stores the session ID returned from the server      //session ID存储在浏览器的cookie中
On subsequent requests, the session ID is verified against the database and if valid the request is processed.
Once a user logs out of the app, the session is destroyed on the server-side.
//若cookie被盗：加ip限制，不允许在另一台电脑上登陆
//登出的时候需要server端销毁所有的session信息

Token-Based Authentication
How it works
token会返回完整的信息给前端
A user enters their login credentials (=username + password).
The server verifies the credentials are correct and created an encrypted and signed token with a private key ( { username: “vincent”, exp: “2019/1/9/10:00” }, private key => token). 
Client-side stores the token returned from the server.
On subsequent requests, the token is decoded with the same private key and if valid the request is processed.
Once a user logs out, the token is destroyed client-side, no interaction with the server is necessary.
//token不需要存储在server端，只在前端销毁token即可

//session和token里不需要包含密码信息，在生成的时候判断好了就行了
Advantages of Token-Based Authentication
Stateless, Scalable and Decoupled
Stateless: The back-end does not need to keep a record of tokens. 
Self-contained, containing all the data required to check its validity. No DB lookup is needed. 
Mobile Friendly：移动平台和cookie的结合不是很好
Native mobile platforms and cookies do not mix well. With a session-based approach, you simply store the session ID in a cookie. 
Disadvantages of Token-Based Authentication：
The size of a token is usually larger than a session id.
token中每个用户的key都是一样的，一百万个用户同时登陆服务器没有压力。但如果是session的话，就要存一百万个sessionID存在server。
生成session之后，需要同步到数据库的每一个copy里


        exists, err = client.IndexExists(USER_INDEX).Do(context.Background())    //新建一个库用来存储User的用户名和密码
        if err != nil {
                panic(err)
        }

        if !exists {
                mapping := `{
                        "mappings": {
                                "properties": {
                                        "username": {"type": "keyword"},     //根据username检索这个人存不存在
                                        "password": {"type": "keyword", "index": false},
                                        "age":      {"type": "long", "index": false},
                                        "gender":   {"type": "keyword", "index": false}
                                }
                        }
                }`
                _, err = client.CreateIndex(USER_INDEX).Body(mapping).Do(context.Background())
                if err != nil {
                        panic(err)
                }
        }

//更新SaveToES使得其不只能存post，还能存user，使之generalize
func saveToES(i interface{}, index string, id string) error {   //用interface代表所有类型的数据
        client, err := elastic.NewClient(elastic.SetURL(ES_URL))
        if err != nil {
                return err
        }

        _, err = client.Index().
                Index(index).
                Id(id).
                BodyJson(i).
                Do(context.Background())

        if err != nil {
                return err
        }

        return nil
}

User.go:

package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "reflect"
    "regexp"
    "time"
     jwtmiddleware "github.com/auth0/go-jwt-middleware"       
     jwt "github.com/dgrijalva/jwt-go"

    jwt "github.com/dgrijalva/jwt-go"     //JWT建立token
    "github.com/olivere/elastic"
)
const (
    USER_INDEX = "user"
)

type User struct {
    Username string `json:"username"`
    Password string `json:"password"`
    Age      int64  `json:"age"`
    Gender   string `json:"gender"`
}
var mySigningKey = []byte("secret")  //加密密钥

func checkUser(username, password string) (bool, error) {     //判断一个用户存不存在
        query := elastic.NewTermQuery("username", username)
        searchResult, err := readFromES(query, USER_INDEX)    //通过用户名读数据
        if err != nil {
                return false, err
        }

        var utype User
        for _, item := range searchResult.Each(reflect.TypeOf(utype)) {   //判断密码是否匹配
                u := item.(User)               //item转换成user格式
                if u.Password == password {
                        fmt.Printf("Login as %s\n", username)
                        return true, nil
                }
        }
        return false, nil
}

func addUser(user *User) (bool, error) {
        query := elastic.NewTermQuery("username", user.Username)
        searchResult, err := readFromES(query, USER_INDEX)
        if err != nil {
                return false, err
        }

        if searchResult.TotalHits() > 0 {    //通过查看result结果个数是不是0来判断该用户名有没有注册过
                return false, nil
        }

        err = saveToES(user, USER_INDEX, user.Username)
        if err != nil {
                return false, err
        }
        fmt.Printf("User is added: %s\n", user.Username)
        return true, nil
}

func handlerLogin(w http.ResponseWriter, r *http.Request) {    //为什么传入参数一个是pointer一个不是？responsewriter是interface类型，不存在pointer的概念
        fmt.Println("Received one login request")
        w.Header().Set("Content-Type", "text/plain")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        if r.Method == "OPTIONS" {
                return
        }

        //  Get User information from client
        decoder := json.NewDecoder(r.Body)      //把Json数据转换成相应的格式
        var user User
        if err := decoder.Decode(&user); err != nil {     //转换成User的格式
                http.Error(w, "Cannot decode user data from client", http.StatusBadRequest)
                fmt.Printf("Cannot decode user data from client %v\n", err)
                return
        }

        exists, err := checkUser(user.Username, user.Password)     //判断用户是否存在
        if err != nil {
                http.Error(w, "Failed to read user from Elasticsearch", http.StatusInternalServerError)  //是否有错误
                fmt.Printf("Failed to read user from Elasticsearch %v\n", err)
                return
        }

        if !exists {     //若用户不存在
                http.Error(w, "User doesn't exists or wrong password", http.StatusUnauthorized)
                fmt.Printf("User doesn't exists or wrong password\n")
                return
        }
	//生成token：
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{   //claim就是payload，HS256加密算法
                "username": user.Username,                                 //payload内容
                "exp":      time.Now().Add(time.Hour * 24).Unix(),         //过期时间，time.Now:token 生成的时间
        })
	
	
        tokenString, err := token.SignedString(mySigningKey)      //通过密钥加密，tokenString就是加密之后的token
        if err != nil {
                http.Error(w, "Failed to generate token", http.StatusInternalServerError)
                fmt.Printf("Failed to generate token %v\n", err)
                return
        }

        w.Write([]byte(tokenString))     //把token信息写到response body里返回给前端
}

func handlerSignup(w http.ResponseWriter, r *http.Request) {
        fmt.Println("Received one signup request")
        w.Header().Set("Content-Type", "text/plain")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        if r.Method == "OPTIONS" {
                return
        }

        decoder := json.NewDecoder(r.Body)    //把Json数据转换成相应的格式
        var user User
        if err := decoder.Decode(&user); err != nil {  //转换成User的格式
                http.Error(w, "Cannot decode user data from client", http.StatusBadRequest)
                fmt.Printf("Cannot decode user data from client %v\n", err)
                return
        }

        if user.Username == "" || user.Password == "" || regexp.MustCompile(`^[a-z0-9]$`).MatchString(user.Username) {   //判断username和password是否符合要求，不能为空，字符要求
                http.Error(w, "Invalid username or password", http.StatusBadRequest)
                fmt.Printf("Invalid username or password\n")
                return
        }

        success, err := addUser(&user)     //把用户添加到数据库中
        if err != nil {
                http.Error(w, "Failed to save user to Elasticsearch", http.StatusInternalServerError)
                fmt.Printf("Failed to save user to Elasticsearch %v\n", err)
                return
        }

        if !success {
                http.Error(w, "User already exists", http.StatusBadRequest)
                fmt.Println("User already exists")
                return
	 }
        fmt.Printf("User added successfully: %s.\n", user.Username)
}

后台API各自验证token

func main() {
    fmt.Println("started-service")
    
    jwtMiddleware := jwtmiddleware.New(jwtmiddleware.Options{       //用密钥mySigningKey和加密算法jwt.SigningMethodHS256来定义一个jwtMiddleware
        ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {
     	 return []byte(mySigningKey), nil
        },
        SigningMethod: jwt.SigningMethodHS256,
   })

   r := mux.NewRouter()

   r.Handle("/post", jwtMiddleware.Handler(http.HandlerFunc(handlerPost))).Methods("POST", "OPTIONS")
   r.Handle("/search", jwtMiddleware.Handler(http.HandlerFunc(handlerSearch))).Methods("GET", "OPTIONS")
   r.Handle("/cluster", jwtMiddleware.Handler(http.HandlerFunc(handlerCluster))).Methods("GET", "OPTIONS")
   r.Handle("/signup", http.HandlerFunc(handlerSignup)).Methods("POST", "OPTIONS")    //不用token，因为是token创建的过程
   r.Handle("/login", http.HandlerFunc(handlerLogin)).Methods("POST", "OPTIONS")      //不用token，因为是token创建的过程

   log.Fatal(http.ListenAndServe(":8080", r))
}

handlerPost函数更新：                    //通过token拿到用户信息
user := r.Context().Value("user")
    claims := user.(*jwt.Token).Claims                //得到token信息
    username := claims.(jwt.MapClaims)["username"]    //得到token里的username

Google Kubernetes Engine
用来将多个计算机联合形成分布式系统
Controllers --- programs that maintains the state of the cluster
Etcd --- cluster state coordination   //可以快速访问的小数据库，用来处理process moment时各个计算机不同步的问题
Scheduler --- program that finds the right node(s) to deploy your application(s)    //当任务来临时，安排用哪些node来处理这个任务
API Service --- Central component that coordinates the communication between different components
Kubelet -  communicates with the Kubernetes Master
Kube-proxy - a network proxy which reflects Kubernetes networking services on each node.

机器学习项目：
训练一个时间序列模型来识别人物的动作，其实说到底是个分类模型，识别人物动作属于：站，坐，走，躺，弯腰，骑车哪一种。并通过
数据的来源，一个人的身上不同部位放置6个传感器，然后让其作相应的动作，在一个动作的时间内多次采样取样每个传感器在采样时的强度值。
对每个动作中的每一个传感器的时间序列进行特征提取（方差，最大值，中位数等等）。
为避免过拟合和欠拟合问题，对于特征的数量和每个特征的数据量进行调整，获得最佳值。
多分类问题可以简化为二项分类问题，用逻辑回归予以解决


Android项目：
activity：一整个屏幕
Onstart：可见不可操作
Onresume：可见可操作
Onpsuse：可见不可操作，点击share
Onstop：不可见不可操作：任务管理器/刷微博的时候突然来电话

两个activity：
stack：每打开一个新的activity就是在旧的上面摞，每次点返回，就会把新的（当前的、最上面的）activity弹出，显示下面的activity，因为最上面的已经弹出所以就没法再回去了。

Fragment：屏幕上的一部分内容，相当于一个subactivity，相当于一堆view。为什么不用view group代替fragment：因为fragment也有lifecycle
屏幕中的每个元素就是一个view

single activity app：每个fragment可以读相同activity里面的所有数据，相当于process和thread，thread可以共享process里的数据，但两个process之间的数据共享有难度，会被serialized。

AndroidManifest：决定从哪个MainActivity进去、决定用哪种application设置

(7-18上午1小时，没仔细看)
通过Jetpack组件实现 Navigation Component
通过id联系起来的
TinNews-app-src-main-java-com.laioffer.tinnews-ui-save/home/search
每个folder下一个fragment，每个fragment都有一个对应的layout
main-res-navigation

Network with Retrofit
从News API拿到新闻
TinNews-app-src-main-java-com.laioffer.tinnews-model用来存从API读取下来的新闻，为了将Json格式的新闻map成对应的Java类
类方法：
equal：
hashcode：
toString：
Add Network permission：<uses-permission android:name="android.permission.INTERNET" />
Retrofit：
make http request。生成Get/Post request给后端把数据拿过来。因为android没有RestFul方法，就用Retrofit模拟一个client往后端请求数据。

TinNews-app-src-main-java-com.laioffer.tinnews-network-newsAPI：将url拆分/组合
RetrofitClient：生成httprequest。apikey放到header，json code 转换成java：.addConverterFactory(GsonConverterFactory.create())

两种可以拿数据的模式：pull and push

TinNews-app-src-main-java-com.laioffer.tinnews-TinnewsApplication：进行application设置

MVVM：
MVP：model view presenter
MVC：model view controller

viewmodel还可以cache从model返回过来的数据
viewmodel和lifecycle相关联，rotate之后还可以直接用viewmodel的缓存数据，但controller不缓存数据，rotate之后还要重新读取
MVC中数据更新后，controller通知view去更新。MVVM中，view一直盯着viewmodel，viewmodel一更新view也更新

bussiness logic 不一样
view的输入方式不一样，最后都转换成统一的方式去model里拿数据

MVVM library：
    annotationProcessor 'androidx.lifecycle:lifecycle-common-java8:2.2.0'
    implementation 'androidx.lifecycle:lifecycle-viewmodel:2.2.0'
    implementation 'androidx.lifecycle:lifecycle-livedata:2.2.0'
    implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'

view不需要担心view的格式和正确性
从view过来的数据，经过vm会进行判断是否合法，合法则传给model，否则返回给view
view要监听viewmodel的数据变化
LiveData：view要一直监听的数据类型

TinNews-app-src-main-java-com.laioffer.tinnews-Repository-NewsRepository：从NewsAPI获得数据
public LiveData<NewsResponse> getTopHeadlines(String country) {
    MutableLiveData<NewsResponse> topHeadlinesLiveData = new MutableLiveData<>();     //最开始执行，生成一个空的livedata
    newsApi.getTopHeadlines(country)
            .enqueue(new Callback<NewsResponse>() {   //enqueue帮助新建线程
                @Override
                public void onResponse(Call<NewsResponse> call, Response<NewsResponse> response) {   //第三，打开一个新线程将NewsAPI的数据读取到repository
                    if (response.isSuccessful()) {
                        topHeadlinesLiveData.setValue(response.body());
                    } else {
                        topHeadlinesLiveData.setValue(null);
                    }
                }

                @Override
                public void onFailure(Call<NewsResponse> call, Throwable t) {
                    topHeadlinesLiveData.setValue(null);
                }
            });
    return topHeadlinesLiveData;         //其次执行return将最开始生成的空livedate返回。第四，再调用return将新读取的数据返回。
    //返回给viewmodel                     （不在本方法内：//这时，view监听到viewmodel里面livedate从空变成有数据，就讲新数据读取到view）
}
//不把network request放到主线程上，为了在请求的时候不会使app卡住，子线程执行network request，主线程继续运行
asynchronous call/request

TinNews-app-src-main-java-com.laioffer.tinnews-ui-home-Homeviewmodel：//将view的set country操作读进来，然后将变化的数据从model读取

public class HomeViewModel extends ViewModel {

    private final NewsRepository repository;
    private final MutableLiveData<String> countryInput = new MutableLiveData<>();

    public HomeViewModel(NewsRepository newsRepository) {
        this.repository = newsRepository;
    }

    public void setCountryInput(String country) {    //从view读取set的数据
        countryInput.setValue(country);
    }

    public LiveData<NewsResponse> getTopHeadlines() {
        return Transformations.switchMap(countryInput, repository::getTopHeadlines); //view每次set都改变countryInput的值，
	               		       //switchmap方法是将countryInput作为输入传给repository::getTopHeadlines，再将其返回值返回
				       //返回给view
    }
}

TinNews-app-src-main-java-com.laioffer.tinnews-Repository-NewViewModelFactory：
Factory帮助创建带有lifecycle的Java class：将Java class和lifecycle绑定
通过Factory.provider保存view的状态，不会每次获取view都新建。有了factory会把创建的view存起来，下次需要的时候不是新建而是直接到这个view上一次的状态中
public class NewsViewModelFactory implements ViewModelProvider.Factory {

    private final NewsRepository repository;

    public NewsViewModelFactory(NewsRepository repository) {
        this.repository = repository;
    }

    @NonNull
    @Override
    public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
        if (modelClass.isAssignableFrom(HomeViewModel.class)) {
            return (T) new HomeViewModel(repository);
        } else if (modelClass.isAssignableFrom(SearchViewModel.class)) {
            return (T) new SearchViewModel(repository);
        } else {
            throw new IllegalStateException("Unknown ViewModel");
        }
    }
}

TinNews-app-src-main-java-com.laioffer.tinnews-ui-home-HomeFragment：fragment就是view
public class HomeFragment extends Fragment {
    private HomeViewModel viewModel;

    // ... existing code

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        NewsRepository repository = new NewsRepository(getContext());      //目前只是一个单纯的java class还不是viewmodel
        viewModel = new ViewModelProvider(this, new NewsViewModelFactory(repository))    //需要经过factory将其与lifecycle相关联才能变成viewmodel
                .get(HomeViewModel.class);
        viewModel.setCountryInput("us");
        viewModel
                .getTopHeadlines()
                .observe(                          //通过viewmodel.getTopHeadlines()监听newsResponse（viewmodel.getTopHeadlines()的返回值）的变化
                        getViewLifecycleOwner(),
                        newsResponse -> {
                            if (newsResponse != null) {
                                Log.d("HomeFragment", newsResponse.toString());   //将结果打印出来
                            }
                        });
    }
}

Stetho is another very convenient debugging tool. It can be used to view network requests and local database content.
Gander也是为了debug

Manifest列出来整个app里有哪些component
gradle和maven差不多，添加依赖
xml：矢量图，可以无限放大
viewmodel API：LiveData给view用的，setInput给model输入
repository（model）包括两个数据源：network数据（NewsAPI），local的数据（Room）
binding：java class到xml layout的纽带

//将layout和fragment binding在一起组成view
+      binding = FragmentSearchBinding.inflate(inflater, container, false);
+      return binding.getRoot();

SearchFragment下实现search功能：
@Override
public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {   //从view中读取到search关键词，然后放到setsearchInput中
    super.onViewCreated(view, savedInstanceState);

    binding.newsSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
        @Override
        public boolean onQueryTextSubmit(String query) {
            if (!query.isEmpty()) {
                viewModel.setSearchInput(query);
            }
            binding.newsSearchView.clearFocus();
            return true;
       }
        @Override
        public boolean onQueryTextChange(String newText) {
            return false;
        }
    });

RecyclerView：以List的形式显示大量数据，像微博往下翻就会有新数据
Why do we need a recycler view?
A large collection of dynamic content, might be infinite.
Each item in the collection is similar in structure.
Limited memory space to hold all the data and their views.

Q: do you think a chat conversation screen is a recycler view or not?
确实是一个
A recycler view requires an Adapter and LayoutManager. 

notifyDataSetChanged()：每次set数据后让adapter去refresh

SearchNewsAdapter：
  @Override
  public SearchNewsViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {  //创建容器，一个页面能显示几个就创建几个容器
    return null;
  }

  @Override
  public void onBindViewHolder(@NonNull SearchNewsViewHolder holder, int position) {  //recycle的过程，并将不同的view个性化显示（显示其是否被收藏过）

  }

  @Override
  public int getItemCount() {      //总的要装的东西的数量
    return 0;
  }


实现滑动：SwipeAnimationSetting的API，Tinder like的GitHubdocumentation介绍的

ORM、hibernate
ORM：object(class)-relationship(database)-mapping
saving the favorite articles to the local database with an ORM framework Room.
Room简化sql query操作->OO design,不用query具体的table，modelclass可以代表一个table，主要是通过object-oriented方法去操作数据库。
和SpingMVC中的hibernate很相似，annotation-based ORM solution for SQLite on Android。
查Room相应的GitHub

DAO:Data Access Objects。提供一些API来做query用的


Android是muti thread
一直在用main UI thread 没用background thread，不heavy
retrofit会自己进行多线程操作

AysncTask：线程切换，把DB query放在后台运行

阻塞与非阻塞
阻塞与非阻塞是描述进程在访问某个资源时，数据是否准备就绪的的一种处理方式。
同步与异步
同步与异步是指访问数据的机制，同步一般指主动请求并等待IO操作完成的方式。
异步则指主动请求数据后便可以继续处理其它任务，随后等待IO操作完毕的通知。
老王烧开水：
1、普通水壶煮水，站在旁边，主动的看水开了没有？同步的阻塞
2、普通水壶煮水，去干点别的事，每过一段时间去看看水开了没有，水没开就走人。 同步非阻塞
3、响水壶煮水，站在旁边，不会每过一段时间主动看水开了没有。如果水开了，水壶自动通知他。 异步阻塞
4、响水壶煮水，去干点别的事，如果水开了，水壶自动通知他。异步非阻塞

传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作。Selector(多路复用器)用于监听多个通道的事件，因此，单个线程可以监听多个数据通道。
NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，
所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 

提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，
然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。

创建NIO服务端的主要步骤如下：
 打开ServerSocketChannel，监听客户端连接
 绑定监听端口，设置连接为非阻塞模式
 创建Reactor线程，创建多路复用器并启动线程
 将ServerSocketChannel注册到Reactor线程中的Selector上，监听ACCEPT事件
 Selector轮询准备就绪的key
 Selector监听到新的客户端接入，处理新的接入请求，完成TCP三次握手，简历物理链路
 设置客户端链路为非阻塞模式
 将新接入的客户端连接注册到Reactor线程的Selector上，监听读操作，读取客户端发送的网络消息
 异步读取客户端消息到缓冲区
 对Buffer编解码，处理半包消息，将解码成功的消息封装成Task
 将应答消息编码为Buffer，调用SocketChannel的write将消息异步发送给客户端

BIO的服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理 处理完成后，
通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通宵模型。

HashMap的底层原理：
允许使用null值和null键，此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 
哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式。数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的
HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。
当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。
get方法的实现相对简单，key(hashcode)–>hash–>indexFor–>最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。
put方法,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。

Iterator：
迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。
ArrayList list = new ArrayList();
 //此处省略list的具体赋值过程
 Iterator it = list.iterator();
         while(it.hasNext()){
             System.out.println(it.next());
}
HashMap<K,V> myMap=new HashMap<K,V>();
 //省略myMap的赋值过程
 for(Iterator<Map.Entry<K,V>> it=myMap.entrySet().iterator();it.hasNext();){
             System.out.println(it.next());
 }
 HashMap<K,V> myMap=new HashMap<K,V>();
 //省略myMap赋值过程
 for(Object oj:myMap.entrySet()){
             System.out.println(oj);
 }

Runnable和callable区别：
1）Runnable提供run方法，无法通过throws抛出异常，所有CheckedException必须在run方法内部处理。Callable提供call方法，直接抛出Exception异常。
2）Runnable的run方法无返回值，Callable的call方法提供返回值用来表示任务运行的结果
3）Runnable可以作为Thread构造器的参数，通过开启新的线程来执行，也可以通过线程池来执行。而Callable只能通过线程池执行。

Runnable使用：
public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
Callable使用：
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}

线程池：
为了避免重复的创建线程，线程池的出现可以让线程进行复用。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。
线程池的优势：
（1）降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；
（2）提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；
（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。
线程池流程：
1、判断核心线程池是否已满，没满则创建一个新的工作线程来执行任务。已满则。
2、判断任务队列是否已满，没满则将新提交的任务添加在工作队列，已满则。
3、判断整个线程池是否已满，没满则创建一个新的工作线程来执行任务，已满则执行饱和策略。
如何配置线程池：
CPU密集型任务
尽量使用较小的线程池，一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。
IO密集型任务
可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。

1、newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）
2、newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）
3、newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。
4、newScheduledThreadPool：适用于执行延时或者周期性任务。

锁：
乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。
悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

悲观锁：


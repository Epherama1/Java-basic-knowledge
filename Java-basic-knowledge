JVM JRE和JDK区别与联系:

JVM + 核心类库 = JRE
JRE + java开发工具（javac.exe/jar.exe) = JDK
这是因为我们是开发人员,我们是写软件的,软件光能运行不行啊,得给我们一个地方让我们来写代码吧?所以就需要java开发工具给我们腾出一个地儿来,好让我们coding

JVM:
JVM 是 Java Virtual Machine（Java虚拟机）的缩写，它是整个 java 实现跨平台的最核心的部分，所有的 java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。
JVM 是 Java 平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。
JVM 通过抽象操作系统和 CPU 结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。
JVM 的主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或对应的系统调用，保护用户免被恶意程序骚扰。

JRE:
光有 JVM 还不能让 class 文件执行，因为在解释 class 的时候 JVM 需要调用解释所需要的类库 lib。
在 JDK 的安装目录里你可以找到 jre 目录，里面有两个文件夹 bin 和 lib,在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 jvm 和 lib 和起来就称为 jre。所以，在你写完java程序编译成.class之后，你可以把这个 .class 文件和 jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。
JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。

JDK:
在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。
bin： 最主要的是编译器（javac.exe）
include： java 与 JVM 交互用的头文件
lib： 类库
jre： java 运行环境
注意：这里的bin、lib文件夹和jre里的bin、lib是不同的.

总的来说，JDK 是用于 java 程序的开发,而 jre 则是只能运行 class 而没有编译的功能。
eclipse、idea 等其他 IDE 有自己的编译器而不是用 JDK bin 目录中自带的，所以在安装时你会发现他们只要求你选jre 路径就 ok 了。

JDK，JRE，JVM 三者的联系:
jdk 是 JAVA 程序开发时用的开发工具包，其内部也有 JRE 运行环境 JRE 。JRE 是 JAVA 程序运行时需要的运行环境，就是说如果你光是运行 JAVA 程序而不是去搞开发的话，只安装 JRE 就能运行已经存在的 JAVA 程序了。JDK、JRE 内部都包含 JAVA 虚拟机 JVM，JAVA 虚拟机内部包含许多应用程序的类的解释器和类加载器等等。




MAVEN:
使之项目描述结构清晰，任何人接手的成本比较低。
而且一个项目可能依赖于其他的项目和第三方的组件才能顺利完成，Maven提供了仓库的概念，让这些依赖项放进仓库中，项目想要从仓库中去取，其他项目组也需要，OK，从仓库中去取，不必每个人去开源项目的站点去苦苦搜寻了。
通过Maven辅助管理项目，更能发现项目中哪些模块是重复的轮子。
Maven就是这个超市，只是它卖的不是红烧排骨，而是一个jar包已经和它有依赖关系的其他jar包。这样，你就不用再开撸java代码前，去各个网站下载各种不同的jar包了，也不用考虑它们之间的依赖关系。



Java SE(Java Platform,Standard Edition)，应该先说这个，因为这个是标准版本。
Java EE (Java Platform，Enterprise Edition)，java 的企业版本
Java ME(Java Platform，Micro Edition)，java的微型版本。
se写桌面应用，ee写web应用，me写移动应用。但现在me被安卓取代了。ee用的很少，用的都是在ee上面衍生出来的spring。



servlet接口定义的是一套处理网络请求的规范，所有实现servlet的类，都需要实现它那五个方法，其中最主要的是两个生命周期方法 init()和destroy()，还有一个处理请求的service()，
也就是说，所有实现servlet接口的类，或者说，所有想要处理网络请求的类，都需要回答这三个问题：你初始化时要做什么, 你销毁时要做什么, 你接受到请求时要做什么
tomcat才是与客户端直接打交道的家伙，他监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理，然后调用那个servlet的service方法，service方法返回一个response对象，tomcat再把这个response返回给客户端。

Tomcat其实是Web服务器和Servlet容器的结合体。
而Web服务器的作用说穿了就是：将某个主机上的资源映射为一个URL供外界访问。
其中接收请求和响应请求是共性功能，且没有差异性。大家就把接收和响应两个步骤抽取成Web服务器：https://pic2.zhimg.com/80/v2-3d86f470ec1dc31bbe93d1df2c30fa47_1440w.jpg?source=1940ef5c
但处理请求的逻辑是不同的。没关系，抽取出来做成Servlet，交给程序员自己编写。
随着后期互联网发展，出现了三层架构，所以一些逻辑就从Servlet抽取出来，分担到Service和Dao。
但是Servlet并不擅长往浏览器输出HTML页面，所以出现了JSP。

JSP全称Java Server Page，直译就是“运行在服务器端的页面”。
服务器内部会经历一次动态资源（JSP）到静态资源（HTML）的转化，服务器会自动帮我们把JSP中的HTML片段和数据拼接成静态资源响应给浏览器。
也就是说JSP运行在服务器端，但最终发给客户端的都已经是转换好的HTML静态页面（在响应体里）。服务器并没有把JSP文件发给浏览器。
JSP = HTML + Java片段（各种标签本质上还是Java片段）
JSP本质是一个Java类（Servlet），是在服务器混的，只不过它输出结果是HTML。
JSP就是一个Servlet

从Tomcat开始，我们再也没写过main方法。以前，一个main方法启动，程序间的调用井然有序，我们知道程序所有流转过程。
框架就像一个傀儡师，我们写的程序是傀儡，顶多就是给傀儡化化妆、打扮打扮，实际的运作全是傀儡师搞的。

其实请求、响应这么一来一回，无非要的就两样东西：数据+HTML骨架。
1.卖家组装好商品后再发货（JSP）
2.卖家把部件拆开，运到之后买家自己组装（AJAX+HTML）
JSP是服务器端的，它的局限性在于数据必须在返回给客户端之前就“装载”完毕。不然HTML都已经发出去了，你就没办法跑到浏览器里把数据给它安上。而有了AJAX，就可以实现零件发送、目的地组装了。





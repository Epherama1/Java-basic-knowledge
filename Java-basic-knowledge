JVM JRE和JDK区别与联系:

JVM + 核心类库 = JRE
JRE + java开发工具（javac.exe/jar.exe) = JDK
这是因为我们是开发人员,我们是写软件的,软件光能运行不行啊,得给我们一个地方让我们来写代码吧?所以就需要java开发工具给我们腾出一个地儿来,好让我们coding

JVM:
JVM 是 Java Virtual Machine（Java虚拟机）的缩写，它是整个 java 实现跨平台的最核心的部分，所有的 java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。
JVM 是 Java 平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。
JVM 通过抽象操作系统和 CPU 结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。
JVM 的主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或对应的系统调用，保护用户免被恶意程序骚扰。

JRE:
光有 JVM 还不能让 class 文件执行，因为在解释 class 的时候 JVM 需要调用解释所需要的类库 lib。
在 JDK 的安装目录里你可以找到 jre 目录，里面有两个文件夹 bin 和 lib,在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 jvm 和 lib 和起来就称为 jre。所以，在你写完java程序编译成.class之后，你可以把这个 .class 文件和 jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。
JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。

JDK:
在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。
bin： 最主要的是编译器（javac.exe）
include： java 与 JVM 交互用的头文件
lib： 类库
jre： java 运行环境
注意：这里的bin、lib文件夹和jre里的bin、lib是不同的.

总的来说，JDK 是用于 java 程序的开发,而 jre 则是只能运行 class 而没有编译的功能。
eclipse、idea 等其他 IDE 有自己的编译器而不是用 JDK bin 目录中自带的，所以在安装时你会发现他们只要求你选jre 路径就 ok 了。

JDK，JRE，JVM 三者的联系:
jdk 是 JAVA 程序开发时用的开发工具包，其内部也有 JRE 运行环境 JRE 。JRE 是 JAVA 程序运行时需要的运行环境，就是说如果你光是运行 JAVA 程序而不是去搞开发的话，只安装 JRE 就能运行已经存在的 JAVA 程序了。JDK、JRE 内部都包含 JAVA 虚拟机 JVM，JAVA 虚拟机内部包含许多应用程序的类的解释器和类加载器等等。




MAVEN:
使之项目描述结构清晰，任何人接手的成本比较低。
而且一个项目可能依赖于其他的项目和第三方的组件才能顺利完成，Maven提供了仓库的概念，让这些依赖项放进仓库中，项目想要从仓库中去取，其他项目组也需要，OK，从仓库中去取，不必每个人去开源项目的站点去苦苦搜寻了。
通过Maven辅助管理项目，更能发现项目中哪些模块是重复的轮子。
Maven就是这个超市，只是它卖的不是红烧排骨，而是一个jar包已经和它有依赖关系的其他jar包。这样，你就不用再开撸java代码前，去各个网站下载各种不同的jar包了，也不用考虑它们之间的依赖关系。



Java SE(Java Platform,Standard Edition)，应该先说这个，因为这个是标准版本。
Java EE (Java Platform，Enterprise Edition)，java 的企业版本
Java ME(Java Platform，Micro Edition)，java的微型版本。
se写桌面应用，ee写web应用，me写移动应用。但现在me被安卓取代了。ee用的很少，用的都是在ee上面衍生出来的spring。



servlet接口定义的是一套处理网络请求的规范，所有实现servlet的类，都需要实现它那五个方法，其中最主要的是两个生命周期方法 init()和destroy()，还有一个处理请求的service()，
也就是说，所有实现servlet接口的类，或者说，所有想要处理网络请求的类，都需要回答这三个问题：你初始化时要做什么, 你销毁时要做什么, 你接受到请求时要做什么
tomcat才是与客户端直接打交道的家伙，他监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理，然后调用那个servlet的service方法，service方法返回一个response对象，tomcat再把这个response返回给客户端。

Tomcat其实是Web服务器和Servlet容器的结合体。
而Web服务器的作用说穿了就是：将某个主机上的资源映射为一个URL供外界访问。
其中接收请求和响应请求是共性功能，且没有差异性。大家就把接收和响应两个步骤抽取成Web服务器：https://pic2.zhimg.com/80/v2-3d86f470ec1dc31bbe93d1df2c30fa47_1440w.jpg?source=1940ef5c
但处理请求的逻辑是不同的。没关系，抽取出来做成Servlet，交给程序员自己编写。
随着后期互联网发展，出现了三层架构，所以一些逻辑就从Servlet抽取出来，分担到Service和Dao。
但是Servlet并不擅长往浏览器输出HTML页面，所以出现了JSP。

JSP全称Java Server Page，直译就是“运行在服务器端的页面”。
服务器内部会经历一次动态资源（JSP）到静态资源（HTML）的转化，服务器会自动帮我们把JSP中的HTML片段和数据拼接成静态资源响应给浏览器。
也就是说JSP运行在服务器端，但最终发给客户端的都已经是转换好的HTML静态页面（在响应体里）。服务器并没有把JSP文件发给浏览器。
JSP = HTML + Java片段（各种标签本质上还是Java片段）
JSP本质是一个Java类（Servlet），是在服务器混的，只不过它输出结果是HTML。
JSP就是一个Servlet

从Tomcat开始，我们再也没写过main方法。以前，一个main方法启动，程序间的调用井然有序，我们知道程序所有流转过程。
框架就像一个傀儡师，我们写的程序是傀儡，顶多就是给傀儡化化妆、打扮打扮，实际的运作全是傀儡师搞的。

其实请求、响应这么一来一回，无非要的就两样东西：数据+HTML骨架。
1.卖家组装好商品后再发货（JSP）
2.卖家把部件拆开，运到之后买家自己组装（AJAX+HTML）
JSP是服务器端的，它的局限性在于数据必须在返回给客户端之前就“装载”完毕。不然HTML都已经发出去了，你就没办法跑到浏览器里把数据给它安上。而有了AJAX，就可以实现零件发送、目的地组装了。


项目一：
RPC(Remote Procedure Call): a function call to a remote server. 
Java Servlet: Java class to handle RPC on the server-side.
Tomcat is an environment to run your web service, it provides low-level support such as making TCP connections, 
receiving requests from clients, finding the correct service to handle that request, and sending a response back.

Normally we don’t return static HTML code to the front end directly because it should be created by a front-end developer. 
We just need to return the correct data that should be displayed by the frontend. In our project, we’ll use JSON as for body format.

because we’re using some features only available in JavaSE-1.8+。 //what kind of features?
Open pom.xml file, set java version and add Tomcat library as dependency of your project. 

写的Java程序存放在src/main/java/rpc，但需要在servelet-mapping建立映射


JSON: JavaScript Object Notation(JavaScript 对象表示法)
省空间，基本没浪费的字符。标准，主流都用它。语言无关。类型安全。
response.setContentType("application/json"); //设置数据类型

response.getWriter()的作用
PrintWriter out = response.getWriter();
getWriter()返回一个PrintWriter object
但是为什么用response呢？而不是new一个PrintWriter对象呢？
 
答：
代码首句的意思是拿到流（可以理解为管道）对象，而非response这个实体，他拿到了PrintWriter这个类的字符流对象，然后对流进行操作。
PrintWriter类是Writer类的子类。
你做的操作的结果应该想要反映到response对应的位置，于是你要拿到属于response的流，而不是new一个出来。
这里的out对象是从Web容器中获取到的，而不是你新创建的，web容器加载servlet的时候已经为您创建好了out对象，你只要获取到然后使用就可以了！

JSONArrray is the structure that contains a series of JSONObject.

HTML - 页面结构
CSS - 页面的样式表现
JavaScript - 交互行为


HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包。
HTTP Client和浏览器有点像，都可以用来发送请求，接收服务端响应的数据。但它不是浏览器，没有用户界面。HttpClient是一个HTTP通信库，只通过其API用于传输和接受HTTP消息。

P161：为什么要引入Httpclient？他的作用是什么？之前的serverletresponse为什么不继续用了？：
为了在后端实现客户端的角色。在后端充当客户端角色给其他的后端发送http请求。
client(前端) -> serverlet -> Github client -> Github server
serverlet和GitHub client可以合在一起
一个httpclient可以发送多个请求

Example1：
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpGet = new HttpGet("http://targethost/homepage");
CloseableHttpResponse response1 = httpclient.execute(httpGet);

try {
    System.out.println(response1.getStatusLine()); //判断状态是否正确
    HttpEntity entity1 = response1.getEntity();    //读取http response的body

    // do something useful with the response body
    // and ensure it is fully consumed
    EntityUtils.consume(entity1);    //如果是发送两个请求，则第一个请求发送完要调用一下consume
} finally {
    response1.close();
}

Example2:自带garbage collection（consume and close）
CloseableHttpClient httpclient = HttpClients.createDefault();

try {
    HttpGet httpget = new HttpGet("http://httpbin.org/");
    System.out.println("Executing request " + httpget.getRequestLine());

    // Create a custom response handler
    ResponseHandler<String> responseHandler = new ResponseHandler<String>() {

        @Override
        public String handleResponse(
                final HttpResponse response) throws ClientProtocolException, IOException {
            int status = response.getStatusLine().getStatusCode();
            if (status >= 200 && status < 300) {
                HttpEntity entity = response.getEntity();
                return entity != null ? EntityUtils.toString(entity) : null;
            } else {
                throw new ClientProtocolException("Unexpected response status: " + status);
            }
        }

    };

    String responseBody = httpclient.execute(httpget, responseHandler);
    System.out.println("----------------------------------------");
    System.out.println(responseBody);
} finally {
    httpclient.close();
}

iimplement：
public JSONArray search(double lat, double lon, String keyword) {  //根据给出的地理位置和关键词，以Jason array的形式返回response的body
		if (keyword == null) {
			keyword = DEFAULT_KEYWORD;
		}
		try {
			keyword = URLEncoder.encode(keyword, "UTF-8");  //url中空格是特殊字符，url不支持，需要转码，浏览器会自动转换。但是这个是一个充当client的后台程序，但这就需要自己写转码的程序.若URL中出现空格，则空格后的内容等于没有，只按空格前的内容搜索。
		} catch (UnsupportedEncodingException e) {   //点击surround with try/catch
			e.printStackTrace();
		}
		String url = String.format(URL_TEMPLATE, keyword, lat, lon); //匹配template里的%s
		
		CloseableHttpClient httpclient = HttpClients.createDefault();  //定义httpclient

	    // Create a custom response handler
	    ResponseHandler<JSONArray> responseHandler = new ResponseHandler<JSONArray>() {   //都设置为JSONArray

	        @Override
	        public JSONArray handleResponse(                             //都设置为JSONArray
	                final HttpResponse response) throws IOException {
	            if (response.getStatusLine().getStatusCode() != 200) {   //判断response是否返回正确
	            	return new JSONArray();                                 //不正确的话就直接返回一个长度为0的JSONArray
	            }
	            HttpEntity entity = response.getEntity();                //判断body是否为空
	            if (entity == null) {
	            	return new JSONArray();
	            }
	            String responseBody = EntityUtils.toString(entity);      //把body转成string格式
	            return new JSONArray(responseBody);                      //把string变成JASONArray
	        }
	    };
	    
		try {
			return httpclient.execute( new HttpGet(url), responseHandler);
		} catch (ClientProtocolException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}

		return new JSONArray();
	}
 
update doGet():
import external.GitHubClient;

public class SearchItem extends HttpServlet {
      ...
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		double lat = Double.parseDouble(request.getParameter("lat"));
		double lon = Double.parseDouble(request.getParameter("lon"));

		GitHubClient client = new GitHubClient();
		RpcHelper.writeJsonArray(response, client.search(lat, lon, null)); //把client search的结果写到要返回的response中
	}


entity：数据清理之后的数据结构
设置一个Item类，并写好让外界访问的API：getter

实现可以将某些参数不初始化来定义一个对象：
builder.setItemId("abcd");
Item item = builder.build();

public static class ItemBuilder {
		private String itemId;
		private String name;
		private String address;
		private String imageUrl;
		private String url;
		private Set<String> keywords;

		public void setItemId(String itemId) {
			this.itemId = itemId;
		}

		public void setName(String name) {
			this.name = name;
		}

		public void setAddress(String address) {
			this.address = address;
		}

		public void setImageUrl(String imageUrl) {
			this.imageUrl = imageUrl;
		}

		public void setUrl(String url) {
			this.url = url;
		}

		public void setKeywords(Set<String> keywords) {
			this.keywords = keywords;
		}

		public Item build() {          //要传的参数传完后，最后调用一次build()一起初始化
			return new Item(this);
		}
	}


getString()用法？啥时候用？
List<List<String>> keywords = MonkeyLearnClient.extractKeywords(descriptionList.toArray(new String[descriptionList.size()])); //把List转化成Array
Set没有order，List有Order

应用JDBC在Java中操作数据库
table之间是有联系的，要按一定顺序建立和删除

Primary key：不能为空，不能重复，可以两列绑在一起作为一个primary key，会自动创建索引 null和null不算重复
Foreign key：指向另一个table中的某一列（Primary Key），保证在子table中插入时，某个用户已经在父table里存在。若没有Primary Key，可以声明父table某一列为unique

INSERT INTO history (user_id, item_id) VALUES (?, ?）在userid和itemid的列中插入value对应的数据

若一个class中全都是static方法，不想被别人用来构建对象，可以设置一个私有的构造函数

Apache commons IO
IOUtils.toString

ResultSet:元素为object的set。有个iterator指向第-1个元素，通过next遍历 6.7/1.30

The session object is stored on the server side, only session ID is returned to the client side.
When a user logs out, the session is destroyed. Next time a user comes, he/she has to authenticate again to get a new session.

session和cookie的区别：？？？

logout一般写在post里，有些浏览器会提前cache doGet的内容，这样会导致直接logout

recommendation algorithm：lesson16 6.10

EC2 VM docker deploy：Lesson13 + Lesson19 6.14 14.00
Setup MySQL on Amazon RDS
Amazon Web Service(AWS) Introduction
Amazon Elastic Compute Cloud(EC2)
Elastic Compute Cloud (EC2) allows scalable deployment of applications by providing a Web service through which a user can boot an Amazon Machine Image to create a virtual machine, which Amazon calls an "instance", containing any software desired. 
A user can create, launch, and terminate server instances as needed, paying by the hour for active servers, hence the term "elastic".
Amazon Relational Database Service(RDS)
security group：firewall

数据库建立：先通过EC2建立一个security group，在RDS配置中与之关联
虚拟机建立：launch EC2，设置security group，下载key pair，用命令行从本地连接到虚拟机

Docker：container service
Bins：程序编译后的二进制代码
LIBS：library库
虚拟机上只跑一个程序有点浪费，若跑多个程序，程序之间无法实现百分百隔离，多个人访问同一个虚拟机会有安全漏洞，内存可能重叠
docker实现两个程序的完全隔离
程序的运行可能并不需要OS所有的资源，在这种情况给其配置整个操作系统就有点浪费。在每个docker中，可以有选择的只配置特定资源避免浪费。
EC2配置虚拟机，在虚拟机上运行docker跑程序
dockerfile：标明了此docker中要包含什么：基础资源和要运行的程序
先以当前路径下的dockerfile作为蓝本build一个docker镜像（image），每运行一次这个镜像就会生成一个container，每个镜像里的内容一样
虚拟机的端口号和docker的端口号可以不一样，可以在运行docker的时候相互对应上

Summery ：Lesson20 6.15


项目二：
GKE：Lesson22 6.20
租虚拟机instance部署自己的service和亚马逊EC2类似
GKE可以管理许多台虚拟机instance，可以对这多台虚拟机进行分类和管理；而且可以实现不同虚拟机台数的自动切换，用户多就多一些，用户少就少一些；自带负载均衡器，保证每台虚拟机上的负载相差不大。
但EC2只能在一台上，如果需要多台，则必须一台一台部署
管理单台虚拟机：GCE = EC2

ElasticSearch：
存储用户的message（留言评论）
搜索强大，根据要求可以自主建立各种各样的index，对不同的数据类型有不同形式的优化
非关系型数据库，二维表格，key-value pair数据

GCS：
网盘，相当于文件系统，在线存储文件，储存用户上传的媒体文件。
数据库不适合存储视频和照片：媒体文件用不到数据库的各种功能。数据库功能：结构化存储数据方便查找和更新。
数据库存储数据：数据库 -> 文件系统（操作系统）-> 磁盘。若绕开数据库，直接通过文件系统存入磁盘，则数据库的开销就可以省去了。
都运行在Google cloud平台上，兼容性好
如何将媒体文件和留言相关联：GCS中每一个文件都对应一个独立的网址，把该网址存入到ElasticSearch中

Firewall：
控制虚拟机的访问权限：谁能向虚拟机发请求以及请求都发到哪个端口。0.0.0.0/0向所有用户敞开。
tcp：
8080：go程序测试使用
9200: ElasticSearch测试使用

Use tmux to handle disconnection

Go语言的并发机制
图灵完整
C和C++直接编译成机器语言machine code，可以直接在cpu上运行，内存管理由程序员控制->效率高，可能内存泄漏。smart point智能指针自动释放。
Java有garbage collector
两种数据类型可以任意转换不需要转换函数，隐式转换 ：弱类型。python不是，python是动态类型，随意绑定。
Java编译成byte code。JIT，just in time 直接到machine code。Java静态语言，可以优化。
Go编译型语言，Java和python解释型语言。
Go比C慢：garbage collector，GC的时候有一部分没法执行。
Go的主要用途：并发机制
package：Java，python，go。可见性的控制，package内部可见，不用import。//那同一个package内，不同class之间可以互相访问private的元素吗？

首字母是否大写：public，外部可访问
类型名在变量的后面
Java中：SomeClass var = GetObject() 将var这个变量绑定一个对象 ；C++中：SomeClass* var = GetObject()
多个返回值：
func swap(x, y string) (string, string) {
	return y, x
}
给返回值绑定一个名字，然后直接返回
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
声明变量：若不赋值则有默认值，零假空
var i int

自动判断是否是在初始化：简化写法，但不能在函数外这么写
k ：= 3；
i := 42
f := float64(i)
u := uint(f)
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128

%v可以绑定任何类型的值

常量：const Pi = 3.14

可以给常量一个非常大的整数，超过64位
Big = 1 << 100：将1往左移动100位
Small = Big >> 99：将Big往右移动99位

int32，int64，int128，明确标注

For loop：
for循环不用加括号
for i := 0; i < 10; i++ {
		sum += i
	}
while通过for实现：
for sum < 1000 {
		sum += sum
while(true):
for {
	}

if不用加括号
可以在if前声名变量，保证其作用域在if内：
if v := math.Pow(x, n); v < lim {
		return v
	}

Switch：
可以匹配string，Java也可以匹配string，C不能匹配string
Go的switch中没有break语句
//fallthrough是啥？

Switch当成else if用：
func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}

Defer：
离开作用域的时候执行
func main() {
	defer fmt.Println("world")

	fmt.Println("hello")     //defer：fmt.Println("hello")是个栈
}
用来释放资源：defer f2.Close()，保证离开作用域必定执行。先执行后面的defer，再执行前面的：栈。因为可能后面的要依赖前面的资源。
//Java的yield是啥？
	}
	
指针：
p := &i         // point to i 把i的地址赋给p
fmt.Println(*p) // read i through the pointer 
*p = 21         // set i through the pointer 取以p位地址的值
fmt.Println(i)  // see the new value of i     i变成21了

struct：
type Vertex struct {
	X int
	Y int
}
func main() {
	fmt.Println(Vertex{1, 2})直接初始化struct
}
func main() {
	v := Vertex{1, 2}
	v.X = 4       在外面访问struct的内部元素

指针struct：
func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9
	fmt.Println(v)
}

var (
	v1 = Vertex{1, 2}  // has type Vertex
	v2 = Vertex{X: 1}  // Y:0 is implicit
	v3 = Vertex{}      // X:0 and Y:0
	p  = &Vertex{1, 2} // has type *Vertex
)

数组是定长的：
func main() {
	var a [2]string
	a[0] = "Hello"
	a[1] = "World"
	fmt.Println(a[0], a[1])
	fmt.Println(a)

	primes := [6]int{2, 3, 5, 7, 11, 13}
	fmt.Println(primes)
}

Slice：不定长
func main() {
	primes := [6]int{2, 3, 5, 7, 11, 13}
	var s []int = primes[1:4]    //[)
	fmt.Println(s)
}

浅复制和深复制：
浅：指向同一个内存区间，改一个，另一个也变
深：不同内存区间但值一样

func main() {
	s := []int{2, 3, 5, 7, 11, 13}

	s = s[1:4]
	fmt.Println(s)

	s = s[:2]
	fmt.Println(s)

	s = s[1:]
	fmt.Println(s)
}

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
)

type Location struct {
        Lat float64 `json:"lat"`
        Lon float64 `json:"lon"`
}

type Post struct {
        User     string   `json:"user"`    //相当于转换时的说明，一一对应转换
        Message  string   `json:"message"`
        Location Location `json:"location"`
        Url      string   `json:"url"`
        Type     string   `json:"type"`
        Face     float32  `json:"face"`
}

func main() {
        fmt.Println("started-service")
        http.HandleFunc("/post", handlerPost)  //将函数与请求绑定：若url中是post请求，则调用handlerPost这个函数来处理这个请求
        log.Fatal(http.ListenAndServe(":8080", nil))    //作用？6.20 14:00
}

//练习版handlerpost
func handlerPost(w http.ResponseWriter, r *http.Request) {     //serverlet类似，处理http request并将结果写入response    这是干啥用的？
        // Parse from body of request to get a json object.
        fmt.Println("Received one post request")
        decoder := json.NewDecoder(r.Body)       //准备把Jason的数据转换为其他格式
        var p Post                               //Go数据格式
        if err := decoder.Decode(&p); err != nil {     //转换
                panic(err)
        }

        fmt.Fprintf(w, "Post received: %s\n", p.Message)     //对w做了什么处理？6.20 14:00
}


sudo vim /etc/elasticsearch/elasticsearch.yml
discovery.type: single-node   //不以分布式来运行
ElasticSearch运行端口：9200

为什么选internalIP而不选externalIP？每次重启虚拟机internalIP不改变，外部IP为什么变？IP地址有限
const (
        POST_INDEX = "post"
        ES_URL = "http://YOUR_GCE_INTERNAL_IP_ADDRESS:9200"
)
func main() {
        client, err := elastic.NewClient(elastic.SetURL(ES_URL)) //与数据库建立连接，ES_URL是数据库的网址加端口号，返回两个值，err用来判断是否有错误发生，若运行在同一台虚拟机上localhost也可以，但以防万一不在一台虚拟机上
        if err != nil {
                panic(err)
        }

        exists, err := client.IndexExists(POST_INDEX).Do(context.Background())     //Index就是database，判断数据库POST_INDEX是否存在
                                                                                   //前面是提供参数，Do是真正执行，.Background:空白，没有额外信息
        if err != nil {                                                            //IndexExists是对于ElasticSearch的http请求，context该请求是否有额外参数（提前终止），请求处理的过程转变为Go routine，参数传给Go routine
                panic(err)
        }
        if !exists {	
                mapping := `{    //database的蓝图schema
			”settings“:{
				"number_of_shards":1,    //切片存储
				"number_of_replicas":0   //备份
			}
                        "mappings": {
                                "properties": {  //列
                                        "user":     { "type": "keyword", "index": false },  //数据类型，是否建立索引
                                        "message":  { "type": "keyword", "index": false },  //keyword：string
                                        "location": { "type": "geo_point" },                //geo_point:自动建立2-d树来进行range search
                                        "url":      { "type": "keyword", "index": false },
                                        "type":     { "type": "keyword", "index": false },
                                        "face":     { "type": "float" }
                                }
                        }
                }`
                _, err := client.CreateIndex(POST_INDEX).Body(mapping).Do(context.Background())   //创建数据库
                if err != nil {
                        panic(err)
                }
        }
        fmt.Println("Post index is created.")
}
ElasticSearch本来是有table的概念叫type，但ElasticSearch有个bug，他每个type内不能有同名的列，bug修不好，不能重复也就没必要多个table了，所以没有table这个概念

如何用Go操作ElasticSearch：如何search

//教程
// Search with a term query
ctx := context.Background()
termQuery := elastic.NewTermQuery("user", "olivere")    //以什么样的限制条件去数据库中找数据，找user=olivere的数据，Term：关键词搜索法
searchResult, err := client.Search().                   //searchResult存放返回的数据
    Index("twitter").   // search in index "twitter"
    Query(termQuery).   // specify the query            //确定检索限制条件
    Sort("user", true). // sort by "user" field, ascending
    From(0).Size(10).   // take documents 0-9
    Pretty(true).       // pretty print request and response JSON
    Do(ctx)             // execute                      //Do返回的就是一个pointer指针
if err != nil {
    // Handle error
    panic(err)             //Panic会使得程序停止执行，但没必要，只要告知前端出错即可，特殊情况内存泄漏死锁可以听下程序
}

fmt.Printf("Query took %d milliseconds\n", searchResult.TookInMillis)    //debug

var ttyp Tweet      //Tweet是个struct，ttyp是个Tweet类型的变量            //返回index和value两个参数，不关心index就用_代替
for _, item := range searchResult.Each(reflect.TypeOf(ttyp)) {      //把searchResult中所有的搜索结果检查一下哪一些是能转换成ttyp类型的，把满足条件数据进行循环内操作（转换成ttyp），为了安全地转换
    t := item.(Tweet)       //把item对象转换为Tweet对象
    fmt.Printf("Tweet by %s: %s\n", t.User, t.Message)
}
unmarshal:把Jason格式的数据转变为Go的struct
func(t):深复制
func（&t）：浅复制，执行完func，t会跟着改变

//根据搜索条件query选择出返回值（指针类型）
func readFromES(query elastic.Query, index string) (*elastic.SearchResult, error) {   
        client, err := elastic.NewClient(elastic.SetURL(ES_URL))
        if err != nil {
                return nil, err
        }

        searchResult, err := client.Search().
                Index(index).                  //在哪一个index（database）中
                Query(query).
                Pretty(true).
                Do(context.Background())
        if err != nil {
                return nil, err
        }

        return searchResult, nil
}

//将search的返回值转化为之前定义的目标结构体
func getPostFromSearchResult(searchResult *elastic.SearchResult) []Post {       
        var ptype Post
        var posts []Post

        for _, item := range searchResult.Each(reflect.TypeOf(ptype)) {
                p := item.(Post)
                posts = append(posts, p)
        }
        return posts
}

//根据request中的信息在数据库中进行搜索，并将结果写入到response中返回
func handlerSearch(w http.ResponseWriter, r *http.Request) {
        fmt.Println("Received one request for search")

        w.Header().Set("Content-Type", "application/json")     //通过在header加一个key-value pair告诉前端返回的数据类型是什么

        lat, _ := strconv.ParseFloat(r.URL.Query().Get("lat"), 64)   //r.URL.Query()得到的是url中？后面的内容，类型是string，再把string转换成64位的float
        lon, _ := strconv.ParseFloat(r.URL.Query().Get("lon"), 64)
        // range is optional
        ran := DISTANCE      //默认搜索范围string
        if val := r.URL.Query().Get("range"); val != "" {  //若前端发来搜索范围则使用发来的，val只在if的作用域内有效
                ran = val + "km"        //搜索参数要加一个单位
        }
        fmt.Println("range is ", ran)

        query := elastic.NewGeoDistanceQuery("location")   //按照location距离搜索
        query = query.Distance(ran).Lat(lat).Lon(lon)      //对location的限制条件，在lat和lon确定的点以ran为半径搜索
        searchResult, err := readFromES(query, POST_INDEX)
        if err != nil {
                http.Error(w, "Failed to read post from Elasticsearch", http.StatusInternalServerError)  //返回http的错误写入response内，http.StatusInternalServerError是返回错误代码
                fmt.Printf("Failed to read post from Elasticsearch %v.\n", err)
                return
        }
        posts := getPostFromSearchResult(searchResult)

        js, err := json.Marshal(posts)    //把Go的struct变成Jason数据
        if err != nil {
                http.Error(w, "Failed to parse posts into JSON format", http.StatusInternalServerError)
                fmt.Printf("Failed to parse posts into JSON format %v.\n", err)
                return
        }
        w.Write(js)
}

//教程
func main() {
        ctx := context.Background()

        // Sets your Google Cloud Platform project ID.
        projectID := "YOUR_PROJECT_ID"

        // Creates a client.
        client, err := storage.NewClient(ctx)     //GCS创建client
        if err != nil {
                log.Fatalf("Failed to create client: %v", err)
        }

        // Sets the name for the new bucket.
        bucketName := "my-new-bucket"

        // Creates a Bucket instance.
        bucket := client.Bucket(bucketName)       //在GCS中创建bucket（文件夹）

        // Creates the new bucket.
        if err := bucket.Create(ctx, projectID, nil); err != nil {   //nil:地区的选择，property的设置都是默认选项
                log.Fatalf("Failed to create bucket: %v", err)
        }

        fmt.Printf("Bucket %v created.\n", bucketName)
}

func write(client *storage.Client, bucket, object string) error {
	ctx := context.Background()
	// [START upload_file]
	f, err := os.Open("notes.txt")   //打开一个文件
	if err != nil {
		return err
	}
	defer f.Close()

	wc := client.Bucket(bucket).Object(object).NewWriter(ctx)  //创建一个将文件写入Object的流
	if _, err = io.Copy(wc, f); err != nil {    //将刚才读入的文件复制到流中
		return err
	}
	if err := wc.Close(); err != nil {
		return err
	}
	// [END upload_file]
	return nil
}

//项目代码
//把媒体文件存储在GCS中并返回url
func saveToGCS(r io.Reader, objectName string) (string, error) {    //r：要存储的文件；objectName：网盘中object的名字；string：图片或视频存储成功后返回的检索链接
        ctx := context.Background()
        client, err := storage.NewClient(ctx)
        if err != nil {
                return "", err
        }

        bucket := client.Bucket(BUCKET_NAME)         //创建一个bucket对象，可以用其创建新的bucket或者传入数据
        if _, err := bucket.Attrs(ctx); err != nil {  //通过读取bucket的attribute判断bucket是否已经创建过
                return "", err                        //若不存在则返回错误
        } 

        object := bucket.Object(objectName)         //在文件夹中创建一个名为objectName的文件
        wc := object.NewWriter(ctx)                 //写文件的流
        if _, err := io.Copy(wc, r); err != nil {     //相当于_, err := io.Copy(wc, r)；if err != nil {}
                return "", err
        }

        if err := wc.Close(); err != nil {
                return "", err
        }
	
	//ACL：access control。通过service account实现不同组之间的交互，运行在GCE上的Go程序要访问GCS，通过GCE虚拟机对应的service account。默认只有创建者的service account可以访问，单位了使前端也可以访问URL，需要更改权限
        if err := object.ACL().Set(ctx, storage.AllUsers, storage.RoleReader); err != nil {   //storage.RoleReader读取权限，但没有其他权限；storage.AllUsers所有用户可以读其他用户上传的文件，但只能对自己上传的文件操作  
                return "", err                                                                //但bucket的所有者可以对其中所有的文件操作
        }

        attrs, err := object.Attrs(ctx)     //通过Attribute找到需要返回的链接
        if err != nil {
                return "", err
        }

        fmt.Printf("Image is saved to GCS: %s\n", attrs.MediaLink)
        return attrs.MediaLink, nil         //通过Attribute找到需要返回的链接
}

//vision.go

package main

import (
        "context"
        "fmt"
        vision "cloud.google.com/go/vision/apiv1"  //重命名为vision
)

//判断一张照片里有人脸的概率
// Annotate an image file based on Cloud Vision API, return score and error if exists.
func annotate(uri string) (float32, error) {    //人脸概率float32，GCE内部操作使用的是internal url，内部操作协同工作比较简单
        ctx := context.Background()
        client, err := vision.NewImageAnnotatorClient(ctx)
        if err != nil {
                return 0.0, err
        }
        defer client.Close()

        image := vision.NewImageFromURI(uri)    //通过url读取文件，内部操作协同工作比较简单
        annotations, err := client.DetectFaces(ctx, image, nil, 1)   //返回detect结果
        if err != nil {
                return 0.0, err
        }
        if len(annotations) == 0 {
                fmt.Println("No faces found.")
                return 0.0, nil
        }
        return annotations[0].DetectionConfidence, nil    //DetectionConfidence得到第一个人脸对应的概率
}

HTTP Multipart Request
An HTTP multipart request is an HTTP request that HTTP clients construct to send files and data over to an HTTP Server. 
It is commonly used by browsers and HTTP clients to upload files to the server. 
The content-type "multipart/form-data" should be used for submitting forms that contain files, non-ASCII data, and binary data.


import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
    "path/filepath"     //通过文件后缀判断是图片还是视频
    "reflect"
    "strconv"

    "cloud.google.com/go/storage"
    "github.com/olivere/elastic"
    "github.com/pborman/uuid"
)
var (        //不同的后缀映射成不同的文件类型
        mediaTypes = map[string]string{
                ".jpeg": "image",
                ".jpg":  "image",
                ".gif":  "image",
                ".png":  "image",
                ".mov":  "video",
                ".mp4":  "video",
                ".avi":  "video",
                ".flv":  "video",
                ".wmv":  "video",
        }

//把用户发布的post信息存储在数据库中
func saveToES(post *Post, index string, id string) error {
        client, err := elastic.NewClient(elastic.SetURL(ES_URL))
        if err != nil {
                return err
        }

        _, err = client.Index().   //往数据库中存数据的API index相当于insert
                Index(index).
                Id(id).                   //primary key
                BodyJson(post).           //BodyJson是什么？
                Do(context.Background())

        if err != nil {
                return err
        }
	
        fmt.Printf("Post is saved to index: %s\n", post.Message)
        return nil
}

//处理用户新发布的post：0.Read parameter from client 1.save image to GCS 2.annotate image with vision api 3.save post to ES
func handlerPost(w http.ResponseWriter, r *http.Request) {
        fmt.Println("Received one post request")
        w.Header().Set("Content-Type", "application/json")

        lat, _ := strconv.ParseFloat(r.FormValue("lat"), 64)
        lon, _ := strconv.ParseFloat(r.FormValue("lon"), 64)

        p := &Post{
                User:    r.FormValue("user"),
                Message: r.FormValue("message"),
                Location: Location{
                        Lat: lat,
                        Lon: lon,
                },
        }

        file, header, err := r.FormFile("image")
        if err != nil {
                http.Error(w, "Image is not available", http.StatusBadRequest)
                fmt.Printf("Image is not available %v\n", err)
                return
        }

        suffix := filepath.Ext(header.Filename)
        if t, ok := mediaTypes[suffix]; ok {
                p.Type = t
        } else {
                p.Type = "unknown"
        }

        id := uuid.New()
        mediaLink, err := saveToGCS(file, id)
        if err != nil {
                http.Error(w, "Failed to save image to GCS", http.StatusInternalServerError)
                fmt.Printf("Failed to save image to GCS %v\n", err)
                return
        }
        p.Url = mediaLink

        if p.Type == "image" {
                uri := fmt.Sprintf("gs://%s/%s", BUCKET_NAME, id)
                if score, err := annotate(uri); err != nil {
                        http.Error(w, "Failed to annotate image", http.StatusInternalServerError)
                        fmt.Printf("Failed to annotate the image %v\n", err)
                        return
                } else {
                        p.Face = score
                }
        }

        err = saveToES(p, POST_INDEX, id)
        if err != nil {
                http.Error(w, "Failed to save post to Elasticsearch", http.StatusInternalServerError)
                fmt.Printf("Failed to save post to Elasticsearch %v\n", err)
                return
        }
}







JVM JRE和JDK区别与联系:

JVM + 核心类库 = JRE
JRE + java开发工具（javac.exe/jar.exe) = JDK
这是因为我们是开发人员,我们是写软件的,软件光能运行不行啊,得给我们一个地方让我们来写代码吧?所以就需要java开发工具给我们腾出一个地儿来,好让我们coding

JVM:
JVM 是 Java Virtual Machine（Java虚拟机）的缩写，它是整个 java 实现跨平台的最核心的部分，所有的 java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。
JVM 是 Java 平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。
JVM 通过抽象操作系统和 CPU 结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。
JVM 的主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或对应的系统调用，保护用户免被恶意程序骚扰。

JRE:
光有 JVM 还不能让 class 文件执行，因为在解释 class 的时候 JVM 需要调用解释所需要的类库 lib。
在 JDK 的安装目录里你可以找到 jre 目录，里面有两个文件夹 bin 和 lib,在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 jvm 和 lib 和起来就称为 jre。所以，在你写完java程序编译成.class之后，你可以把这个 .class 文件和 jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。
JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。

JDK:
在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。
bin： 最主要的是编译器（javac.exe）
include： java 与 JVM 交互用的头文件
lib： 类库
jre： java 运行环境
注意：这里的bin、lib文件夹和jre里的bin、lib是不同的.

总的来说，JDK 是用于 java 程序的开发,而 jre 则是只能运行 class 而没有编译的功能。
eclipse、idea 等其他 IDE 有自己的编译器而不是用 JDK bin 目录中自带的，所以在安装时你会发现他们只要求你选jre 路径就 ok 了。

JDK，JRE，JVM 三者的联系:
jdk 是 JAVA 程序开发时用的开发工具包，其内部也有 JRE 运行环境 JRE 。JRE 是 JAVA 程序运行时需要的运行环境，就是说如果你光是运行 JAVA 程序而不是去搞开发的话，只安装 JRE 就能运行已经存在的 JAVA 程序了。JDK、JRE 内部都包含 JAVA 虚拟机 JVM，JAVA 虚拟机内部包含许多应用程序的类的解释器和类加载器等等。




MAVEN:
使之项目描述结构清晰，任何人接手的成本比较低。
而且一个项目可能依赖于其他的项目和第三方的组件才能顺利完成，Maven提供了仓库的概念，让这些依赖项放进仓库中，项目想要从仓库中去取，其他项目组也需要，OK，从仓库中去取，不必每个人去开源项目的站点去苦苦搜寻了。
通过Maven辅助管理项目，更能发现项目中哪些模块是重复的轮子。
Maven就是这个超市，只是它卖的不是红烧排骨，而是一个jar包已经和它有依赖关系的其他jar包。这样，你就不用再开撸java代码前，去各个网站下载各种不同的jar包了，也不用考虑它们之间的依赖关系。



Java SE(Java Platform,Standard Edition)，应该先说这个，因为这个是标准版本。
Java EE (Java Platform，Enterprise Edition)，java 的企业版本
Java ME(Java Platform，Micro Edition)，java的微型版本。
se写桌面应用，ee写web应用，me写移动应用。但现在me被安卓取代了。ee用的很少，用的都是在ee上面衍生出来的spring。



servlet接口定义的是一套处理网络请求的规范，所有实现servlet的类，都需要实现它那五个方法，其中最主要的是两个生命周期方法 init()和destroy()，还有一个处理请求的service()，
也就是说，所有实现servlet接口的类，或者说，所有想要处理网络请求的类，都需要回答这三个问题：你初始化时要做什么, 你销毁时要做什么, 你接受到请求时要做什么
tomcat才是与客户端直接打交道的家伙，他监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理，然后调用那个servlet的service方法，service方法返回一个response对象，tomcat再把这个response返回给客户端。

Tomcat其实是Web服务器和Servlet容器的结合体。
而Web服务器的作用说穿了就是：将某个主机上的资源映射为一个URL供外界访问。
其中接收请求和响应请求是共性功能，且没有差异性。大家就把接收和响应两个步骤抽取成Web服务器：https://pic2.zhimg.com/80/v2-3d86f470ec1dc31bbe93d1df2c30fa47_1440w.jpg?source=1940ef5c
但处理请求的逻辑是不同的。没关系，抽取出来做成Servlet，交给程序员自己编写。
随着后期互联网发展，出现了三层架构，所以一些逻辑就从Servlet抽取出来，分担到Service和Dao。
但是Servlet并不擅长往浏览器输出HTML页面，所以出现了JSP。

JSP全称Java Server Page，直译就是“运行在服务器端的页面”。
服务器内部会经历一次动态资源（JSP）到静态资源（HTML）的转化，服务器会自动帮我们把JSP中的HTML片段和数据拼接成静态资源响应给浏览器。
也就是说JSP运行在服务器端，但最终发给客户端的都已经是转换好的HTML静态页面（在响应体里）。服务器并没有把JSP文件发给浏览器。
JSP = HTML + Java片段（各种标签本质上还是Java片段）
JSP本质是一个Java类（Servlet），是在服务器混的，只不过它输出结果是HTML。
JSP就是一个Servlet

从Tomcat开始，我们再也没写过main方法。以前，一个main方法启动，程序间的调用井然有序，我们知道程序所有流转过程。
框架就像一个傀儡师，我们写的程序是傀儡，顶多就是给傀儡化化妆、打扮打扮，实际的运作全是傀儡师搞的。

其实请求、响应这么一来一回，无非要的就两样东西：数据+HTML骨架。
1.卖家组装好商品后再发货（JSP）
2.卖家把部件拆开，运到之后买家自己组装（AJAX+HTML）
JSP是服务器端的，它的局限性在于数据必须在返回给客户端之前就“装载”完毕。不然HTML都已经发出去了，你就没办法跑到浏览器里把数据给它安上。而有了AJAX，就可以实现零件发送、目的地组装了。


项目一：
RPC(Remote Procedure Call): a function call to a remote server. 
Java Servlet: Java class to handle RPC on the server-side.
Tomcat is an environment to run your web service, it provides low-level support such as making TCP connections, 
receiving requests from clients, finding the correct service to handle that request, and sending a response back.

Normally we don’t return static HTML code to the front end directly because it should be created by a front-end developer. 
We just need to return the correct data that should be displayed by the frontend. In our project, we’ll use JSON as for body format.

because we’re using some features only available in JavaSE-1.8+。 //what kind of features?
Open pom.xml file, set java version and add Tomcat library as dependency of your project. 

写的Java程序存放在src/main/java/rpc，但需要在servelet-mapping建立映射


JSON: JavaScript Object Notation(JavaScript 对象表示法)
省空间，基本没浪费的字符。标准，主流都用它。语言无关。类型安全。
response.setContentType("application/json"); //设置数据类型

response.getWriter()的作用
PrintWriter out = response.getWriter();
getWriter()返回一个PrintWriter object
但是为什么用response呢？而不是new一个PrintWriter对象呢？
 
答：
代码首句的意思是拿到流（可以理解为管道）对象，而非response这个实体，他拿到了PrintWriter这个类的字符流对象，然后对流进行操作。
PrintWriter类是Writer类的子类。
你做的操作的结果应该想要反映到response对应的位置，于是你要拿到属于response的流，而不是new一个出来。
这里的out对象是从Web容器中获取到的，而不是你新创建的，web容器加载servlet的时候已经为您创建好了out对象，你只要获取到然后使用就可以了！

JSONArrray is the structure that contains a series of JSONObject.

HTML - 页面结构
CSS - 页面的样式表现
JavaScript - 交互行为


HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包。
HTTP Client和浏览器有点像，都可以用来发送请求，接收服务端响应的数据。但它不是浏览器，没有用户界面。HttpClient是一个HTTP通信库，只通过其API用于传输和接受HTTP消息。

P161：为什么要引入Httpclient？他的作用是什么？之前的serverletresponse为什么不继续用了？：
为了在后端实现客户端的角色。在后端充当客户端角色给其他的后端发送http请求。
client(前端) -> serverlet -> Github client -> Github server
serverlet和GitHub client可以合在一起

CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpGet = new HttpGet("http://targethost/homepage");
CloseableHttpResponse response1 = httpclient.execute(httpGet);

try {
    System.out.println(response1.getStatusLine()); //判断状态是否正确
    HttpEntity entity1 = response1.getEntity();    //读取http response的body

    // do something useful with the response body
    // and ensure it is fully consumed
    EntityUtils.consume(entity1);    //如果是发送两个请求，则第一个请求发送完要调用一下consume
} finally {
    response1.close();
}





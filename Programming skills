数组的长度：int[] nums.length;
String长度：s.length();
其他的的都是.size()

StringBuilder res = new StringBuilder();         //对string操作多的情况用StringBuilder
res.append(value);
return res.reverse().toString();

List<List<Integer>> res = new ArrayList<>();
private void subsets(int[] nums, int startindex, LinkedList<Integer> buffer)
res.add(new ArrayList<Integer>(buffer));
buffer.removeLast();    //只有LinkedList才有这个方法
subsets(nums, 0 , new ArrayList<>());
LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.
Arrays.sort(nums);
int [] inorder = Arrays.copyOf(preorder, preorder.length);
element.get(k-1);返回前k个元素

path += Integer.toString(root.val);
count.put(n, count.getOrDefault(n, 0) + 1);

output.add(new ArrayList<>(perm));     //向二维list中添加一维list

总结List常用的方法:增(add(Object ele))、删(remove(int index))、改(set(int index, Object ele))、查(get(int index))、插(add(int index,Object ele))、长度(size()).

Queue<ListNode> q = new PriorityQueue<>((n1, n2) -> n1.val - n2.val); //最小堆
if(l!=null){                 //不为空的时候才能将其插入堆
q.add()
q.peek()
q.poll()

public class ListNode{//练习写自己需要的数据结构
        int val;
        ListNode next;
        ListNode() {};
        ListNode(int val){
            this.val = val;
        }
        ListNode(int val, ListNode next){
            this.val = val;
            this.next = next;
        }
    }

s.charAt(i)

int lowestindex = Collections.min(map.values()); //获取map中最小的value
Map<Character, Integer> map = new HashMap<>(); //HashMap中存的是每一个字符和本字符在字符串中的最右端的索引
List<String> wordDict
Set<String> wordDictSet = new HashSet<>(wordDict);   //用List初始化set
wordDictSet.contains(s.substring(j, i)))    //[j,i)


private Map<String, List<Pair<Integer, String>>> M = new HashMap();
if(!M.containsKey(key))
            M.put(key, new ArrayList<Pair<Integer, String>>());
M.get(key).add(new pair(timestamp, value));
List<Pair<Integer, String>> A = M.get(key);
A.get(i).getValue();       //ArrayList通过下标访问

class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0])); //二位数组，根据特定条件排序
        LinkedList<int[]> merged = new LinkedList<>();
        
        for(int[] interval : intervals){             //二维数组遍历
            if(merged.isEmpty() || merged.getLast()[1] < interval[0]){   //判断数组是否为空，得到数组最后一个元素
                merged.add(interval);
            }
            else{
                merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]); //更新数组元素
            }
        }
        return merged.toArray(new int[merged.size()][]);     //将List转为二维数组
    }
}

Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

Stack<Character> stack = new Stack<>();
while (!stack.isEmpty() && Character.isDigit(stack.peek())) {  //判断char是否是数字
                    k = k + (stack.pop() - '0') * base;    //char转数字                int m = Integer.parseInt(String.valueOf(stack.pop()));
char[] result = new char[stack.size()];         //stack复制到数组中
        for(int i = result.length-1 ; i>=0 ; i--)
            result[i] = stack.pop();
        
return new String(result);     //char数组转string

Queue<Integer> queue = new LinkedList<>();
int s = queue.remove();

// At least one of l1 and l2 can still have nodes at this point, so connect
// the non-null list to the end of the merged list.
prev.next = l1 == null ? l2 : l1;      //用在某一个数组链表为空时merge的操作，将剩余的全连上

char到int可以隐式转换，int到char需要显式强制转换

string转为char数组：
for (char c: ("" + (read - anchor + 1)).toCharArray()) {
char数组转为string：
String key = String.valueOf(ca);

取数组的一部分：
chars = Arrays.copyOfRange(chars, 0, pos);

如果放弃狭义递归函数的话，我们不得不借助一个额外的数据结构：栈。
如此看来，无论如何都要用到栈，只不过要么让编译器来维护一个栈（函数栈），要么让程序狗来维护一个栈（数据栈）。
可以把递归看成是自己调用另一个和自己功能一样，但是函数名不同的函数来理解
遍历的话不要用递归（深度优先遍历），要用广度优先遍历


实际上就是一个决策树的遍历过程：https://www.zhihu.com/topic/20745319/top-answers
1、路径：也就是已经做出的选择。
2、选择列表：也就是你当前可以做的选择。
3、结束条件：也就是到达决策树底层，无法再做选择的条件。
回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        # 做选择
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
        # 撤销选择
        路径.remove(选择)
        将该选择再加入选择列表
        
其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」

动态规划：
第一步要明确两点，「状态」和「选择」。
先说状态，如何才能描述一个问题局面？只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，对不对？所以状态有两个，就是「背包的容量」和「可选择的物品」。
再说选择，也很容易想到啊，对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」嘛。

# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)

dp数组是什么？其实就是描述问题局面的一个数组。换句话说，我们刚才明确问题有什么「状态」，现在需要用dp数组把状态表示出来。
首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维dp数组，一维表示可选择的物品，一维表示背包的容量。
dp[i][j] 的定义如下：若只使用前 i 个物品，当背包容量为 j 时，有 dp[i][j] 种方法可以装满背包。





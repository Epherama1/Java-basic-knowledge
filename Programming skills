数组的长度：int[] nums.length;
String长度：s.length();
其他的的都是.size()

StringBuilder res = new StringBuilder();         //对string操作多的情况用StringBuilder
res.append(value);
return res.reverse().toString();

List<List<Integer>> res = new ArrayList<>();
private void subsets(int[] nums, int startindex, LinkedList<Integer> buffer)
res.add(new ArrayList<Integer>(buffer));
buffer.removeLast();    //只有LinkedList才有这个方法
subsets(nums, 0 , new ArrayList<>());
LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.
Arrays.sort(nums);
int [] inorder = Arrays.copyOf(preorder, preorder.length);
element.get(k-1);返回前k个元素

path += Integer.toString(root.val);
count.put(n, count.getOrDefault(n, 0) + 1);

output.add(new ArrayList<>(perm));     //向二维list中添加一维list

总结List常用的方法:增(add(Object ele))、删(remove(int index))、改(set(int index, Object ele))、查(get(int index))、插(add(int index,Object ele))、长度(size()).

Queue<ListNode> q = new PriorityQueue<>((n1, n2) -> n1.val - n2.val); //最小堆
if(l!=null){                 //不为空的时候才能将其插入堆
q.add()
q.peek()
q.poll()

public class ListNode{//练习写自己需要的数据结构
        int val;
        ListNode next;
        ListNode() {};
        ListNode(int val){
            this.val = val;
        }
        ListNode(int val, ListNode next){
            this.val = val;
            this.next = next;
        }
    }

s.charAt(i)

int lowestindex = Collections.min(map.values()); //获取map中最小的value
Map<Character, Integer> map = new HashMap<>(); //HashMap中存的是每一个字符和本字符在字符串中的最右端的索引
List<String> wordDict
Set<String> wordDictSet = new HashSet<>(wordDict);   //用List初始化set
wordDictSet.contains(s.substring(j, i)))    //[j,i)


private Map<String, List<Pair<Integer, String>>> M = new HashMap();
if(!M.containsKey(key))
            M.put(key, new ArrayList<Pair<Integer, String>>());
M.get(key).add(new pair(timestamp, value));
List<Pair<Integer, String>> A = M.get(key);
A.get(i).getValue();       //ArrayList通过下标访问

class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0])); //二位数组，根据特定条件排序
        LinkedList<int[]> merged = new LinkedList<>();
        
        for(int[] interval : intervals){             //二维数组遍历
            if(merged.isEmpty() || merged.getLast()[1] < interval[0]){   //判断数组是否为空，得到数组最后一个元素
                merged.add(interval);
            }
            else{
                merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]); //更新数组元素
            }
        }
        return merged.toArray(new int[merged.size()][]);     //将List转为二维数组
    }
}

Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

Stack<Character> stack = new Stack<>();
while (!stack.isEmpty() && Character.isDigit(stack.peek())) {  //判断char是否是数字
                    k = k + (stack.pop() - '0') * base;    //char转数字                int m = Integer.parseInt(String.valueOf(stack.pop()));
char[] result = new char[stack.size()];         //stack复制到数组中
        for(int i = result.length-1 ; i>=0 ; i--)
            result[i] = stack.pop();
        
return new String(result);     //char数组转string

Queue<Integer> queue = new LinkedList<>();
int s = queue.remove();

// At least one of l1 and l2 can still have nodes at this point, so connect
// the non-null list to the end of the merged list.
prev.next = l1 == null ? l2 : l1;      //用在某一个数组链表为空时merge的操作，将剩余的全连上

char到int可以隐式转换，int到char需要显式强制转换

string转为char数组：
for (char c: ("" + (read - anchor + 1)).toCharArray()) {
char数组转为string：
String key = String.valueOf(ca);

取数组的一部分：
chars = Arrays.copyOfRange(chars, 0, pos);

如果放弃狭义递归函数的话，我们不得不借助一个额外的数据结构：栈。
如此看来，无论如何都要用到栈，只不过要么让编译器来维护一个栈（函数栈），要么让程序狗来维护一个栈（数据栈）。
